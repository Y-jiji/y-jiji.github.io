{"path":"_assets/2301.03943.pdf","text":"IEEE TRANSACTIONS ON INFORMATION FORENSICS AND SECURITY 1 Rethinking Smart Contract Fuzzing: Fuzzing With Invocation Ordering and Important Branch Revisiting Zhenguang Liu, Peng Qian, Jiaxu Yang, Lingfeng Liu, Xiaojun Xu, Qinming He, and Xiaosong Zhang Abstract—Blockchain smart contracts have given rise to a variety of interesting and compelling applications and emerged as a revolutionary force for the Internet. Smart contracts from various ﬁelds now hold over one trillion dollars worth of virtual coins, attracting numerous attacks. Quite a few practitioners have devoted themselves to developing tools for detecting bugs in smart contracts. One line of efforts revolve around static analysis techniques, which heavily suffer from high false positive rates. Another line of works concentrate on fuzzing techniques. Unfortunately, current fuzzing approaches for smart contracts tend to conduct fuzzing starting from the initial state of the contract, which expends too much energy revolving around the initial state of the contract and thus is usually unable to unearth bugs triggered by other states. Moreover, most existing methods treat each branch equally, failing to take care of the branches that are rare or more likely to possess bugs. This might lead to resources wasted on normal branches. In this paper, we try to tackle these challenges from three aspects: (1) In generating function invocation sequences, we explicitly consider data dependencies between functions to fa- cilitate exploring richer states. We further prolong a function invocation sequence S1 by appending a new sequence S2, so that the appended sequence S2 can start fuzzing from states that are different from the initial state. (2) We incorporate a branch distance-based measure to evolve test cases iteratively towards a target branch. (3) We engage a branch search algorithm to discover rare and vulnerable branches, and design an energy allocation mechanism to take care of exercising these crucial branches. We implement IR-Fuzz and extensively evaluate it over 12K real-world contracts. Empirical results show that: (i) IR-Fuzz achieves 28% higher branch coverage than state-of-the- art fuzzing approaches, (ii) IR-Fuzz detects more vulnerabilities and increases the average accuracy of vulnerability detection by 7% over current methods, and (iii) IR-Fuzz is fast, generating an average of 350 test cases per second. Our implementation and dataset are released at https://github.com/Messi-Q/IR-Fuzz, hoping to facilitate future research. Index Terms—Fuzzing, smart contract, vulnerability detection, blockchain, sequence generation, seed evolution. I. INTRODUCTION This work was supported by the National Key R&D Program of China under Grant 2021YFB2700500, the Key R&D Program of Zhejiang Province under Grant 2022C01086 and Grant 2021C01104, and by the Scientiﬁc Research Fund of Zhejiang Provincial Education Department under Grant Y202250832. (Corresponding author: Peng Qian.) Zhenguang Liu, Peng Qian, and Qinming He are with Zhejiang Uni- versity, Hangzhou 310058, China (e-mail: liuzhenguang2008@gmail.com; messi.qp711@gmail.com; hqm@zju.edu.cn). Jiaxu Yang, Lingfeng Liu, and Xiaojun Xu are with School of Computer and Information Engineering, Zhejiang Gongshang University, Hangzhou 310018, China (e-mail: yjx.00@foxmail.com; liulingfengxx@gmail.com; xuxj2022@gmail.com). Xiaosong Zhang is with the Center for Cyber Security, University of Electronic Science and Technology of China, Chengdu 611731, China (e- mail: johnsonzxs@uestc.edu.cn). S MART contracts are programs executing on top of a blockchain system [1]. A smart contract encodes prede- ﬁned contract terms into runnable code. Due to the immutable nature of blockchain, once a smart contract is deployed on the blockchain, its deﬁned rules will be strictly followed during execution. Smart contracts make the automatic execution of contract terms possible, giving rise to a variety of decentralized applications [2], [3]. Notably, not all blockchains support smart contracts. Ethereum, one of the most prominent blockchains enabling the execution of smart contracts, has attracted widespread attention worldwide. So far, tens of millions of contracts have been deployed on Ethereum [4], enabling a broad spectrum of applications, including wallet [5], crowdfunding [6], supply chain [7], and cross-industry ﬁnance [8]. Smart contracts from various ﬁelds now hold over one thousand billion dollars worth of virtual coins, and the number of contracts is still increasing rapidly [2]. Smart contracts have long been appealing targets for attackers since they manipulate so many digital assets. Speciﬁcally, the source code of a Ethereum smart contract will be compiled into bytecode and executed on Ethereum Virtual Machine [9]. Like traditional programs, smart con- tracts may contain vulnerabilities. Therefore, it is important to identify potential vulnerabilities in smart contracts, ideally before their deployments. Malicious attackers may exploit the bugs in smart contracts to gain illegal proﬁts. Recently, there was an increasing number of security vulnerability incidents in smart contracts [10], [11], leading to enormous ﬁnancial losses. One infamous example was the reentrancy attack, i.e., attackers stole more than $130 million worth of digital assets, exploiting the reentrancy vulnerability in the Cream.Finance contract [12]. This case is not isolated, e.g., a delegatecall bug accidentally triggered resulted in freezing over $280 million worth of Ether in the Parity Multisig Wallet contract [13]. Obviously, conducting security vetting on smart contracts to avoid exposing vulnerabilities to attackers is much coveted. Fueled by the maturity of static analysis techniques such as formal veriﬁcation [14] and symbolic execution [15], smart contract vulnerability detection has undergone considerable progress in the past few years. These methods, however, inherently suffer from high false positive rates since they do not actually execute each path. Recent efforts resort to fuzzing techniques [16]–[18], which have the merits of producing neg- ligible false positives in discovering software vulnerabilities. This can be attributed to the fact that fuzzers usually generate test cases to exercise a branch, and report vulnerabilities only when they detect abnormal results during fuzzing. After scrutinizing existing released fuzzers for smart con- tracts, such as [16], [18]–[23], we obtain the following obser-arXiv:2301.03943v2 [cs.CR] 12 Jan 2023 IEEE TRANSACTIONS ON INFORMATION FORENSICS AND SECURITY 2 vations. (1) Current fuzzers (e.g., sFuzz [16] and Harvey [21]) tend to generate function invocation sequences randomly, overlooking the data dependencies (such as read and write dependencies) between functions. More importantly, a smart contract may transition through many different states during its lifecycle [21]. For example, every bet in a gambling contract will change the contract state. However, current methods generally conduct fuzzing starting from the initial state of the contract, which actually expends too much energy revolving around the initial state of the contract and is incapable of unearthing bugs triggered by complex states. (2) Most current approaches fail to take into account the distance between test cases and branch conditions in seed mutation, resulting in generating seeds that have low probabilities to enter a target branch. (3) Existing fuzzers (e.g., ILF [22] and Con- fuzzius [23]) often treat program branches equally. As a result, fuzzers might waste too many resources in fuzzing normal branches and are unable to dive deep into crucial branches that are rare or more likely to have bugs. To tackle these challenges, we propose IR-Fuzz, a fully automatic Fuzzing framework equipped with Invocation or- dering and impoRtant branch revisiting, for detecting security vulnerabilities in Ethereum smart contracts. In particular, IR- Fuzz consists of three key components. Sequence Generation. Usually, there are multiple func- tions within a contract, we introduce a function-invocation- sequence generation strategy, which consists of function in- vocation ordering and sequence prolongation. Speciﬁcally, we build a data ﬂow analyzer to capture the data ﬂow dependencies of global variables and then deﬁne a rule to compute the order priority of each function call, inferring the ordered function invocation sequence. Further, we introduce a prolongation technique to extend the sequence, enforcing the fuzzer to tap into unprecedented states. Seed Optimization. We also present a seed optimiza- tion paradigm, which drives the fuzzer to generate branch- condition-aware test cases. In practice, we employ a branch distance-based measure to select test cases according to how far a test case is from satisfying the condition (e.g., x==10) of a just-missed branch 1. Intuitively, the test case has a higher probability to enter the just-missed branch as the distance decreases. In this way, IR-Fuzz iteratively evolves test cases to get increasingly closer to satisfying the branch conditions, which boosts its ability to ﬁnd a high-quality test case and achieve a higher branch coverage. Energy Allocation. Finally, we design an energy allo- cation mechanism that takes into account the signiﬁcance of a branch. Technically, we ﬁrst propose a branch search algorithm to pick out rare branches and branches that are likely to have vulnerabilities. Then, we formulate a customized energy schedule and develop two rules to guide fuzzing energy allocation. As such, IR-Fuzz can ﬂexibly assign fuzzing resources to more important branches, which increases the overall fuzzing efﬁciency by a large margin (4.9x faster than sFuzz [16]) and further improves branch coverage. 1A just-missed branch stands for the unexplored if -branch or then-branch of a conditional statement (such as if and require) or a recurrent statement (such as for and while). We implement IR-Fuzz and extensively evaluate this system over 12K real-world smart contracts. Experimental results show that: (i) IR-Fuzz achieves high average branch cover- age by up to 90%, yielding a 28% improvement compared with state-of-the-art fuzzing approaches. (ii) IR-Fuzz identiﬁes more vulnerabilities and increases the average accuracy of vulnerability detection by 7% over current methods. (iii) IR- Fuzz generates an average of 350 test cases per second, in most cases orders-of-magnitude faster than conventional fuzzers. Our key contributions can be summarized as follows: • We design and implement a novel framework IR-Fuzz for smart contract fuzzing, which consists of three key com- ponents, i.e., function invocation sequence prolongation, branch-distance-driven seed optimization, and branch- importance-aware energy allocation. • Within the framework, we present a sequence generation strategy to infer high-quality function invocation se- quences, steering fuzzing to explore unprecedented states. Further, we introduce a seed optimization paradigm that incorporates a branch distance-based measure to select and evolve test cases towards new branches. Finally, we develop a branch search algorithm to discover rare and vulnerable branches, and propose an energy allocation mechanism to concentrate on these critical branches. • We evaluate IR-Fuzz over large-scale real world smart contracts, and empirical results show that the proposed techniques are indeed useful in achieving high branch coverages. IR-Fuzz surpasses state-of-the-art fuzzers and overall provides interesting insights. As a side contribu- tion, we construct a large benchmark dataset for evaluat- ing smart contract fuzzing approaches. Our implementa- tion and dataset are released, hoping to inspire others. II. RELATED WORK A. Smart Contract Vulnerability Detection Since blockchain endows smart contracts with unalterable nature, there is no way to patch the vulnerabilities of a smart contract without forking the blockchain (almost an impossible mission), regardless of how much money the contract holds or how popular it is [2], [24]–[26]. Therefore, it is critical to conduct security vetting for smart contracts, especially before their deployments. Early works for smart contract vulnerability detection employ formal veriﬁcation techniques. For example, [14] introduces a framework to compile smart contracts to EVM bytecode and then put them into an existing veriﬁcation system. [27] proposes a formal model and veriﬁes smart contracts using the Isabelle/HOL tool. Further, [28] and [29] deﬁne the formal semantics of contracts using the F* framework and the K framework, respectively. Although these frameworks provide strong formal veriﬁcation guarantees, they are still semi-automated and yield high false positives. Another stream of works rely on symbolic execution methods, such as Oyente [15], Slither [30], and Securify [31]. Oyente is one of the pioneering works to perform symbolic execution on smart contracts, which checks bugs based on expert- deﬁned rules. [30] converts smart contracts into intermediate IEEE TRANSACTIONS ON INFORMATION FORENSICS AND SECURITY 3 representations and conducts static analysis to detect vulnera- bilities. Whereas symbolic execution is a powerful technique for discovering bugs, it still suffers from the inherent problem of symbolic execution path explosion. Recent efforts resort to using fuzzing techniques for smart contract vulnerability detection. ContractFuzzer [20] is the ﬁrst to apply fuzzing techniques to smart contracts and identi- ﬁes vulnerabilities by monitoring runtime behaviors during fuzzing. ReGuard [32] and Harvey [21] are dedicated to generating a number of test cases that cover as many paths as possible to trigger a vulnerability. ILF [22] and sFuzz [16] aim to design a feedback-based seed mutation strategy. Despite the practicality of fuzzing techniques, existing fuzzers still have difﬁculties in achieving high coverage and fuzzing efﬁciency. Instead, our work alleviates the issues by carefully designing a sequence generation strategy, a seed optimization paradigm, and an energy allocation mechanism. B. Greybox Fuzzing Fuzzing techniques have been proven as an effective way to discover software vulnerabilities. According to how much information is available about the program under test [33], fuzzing techniques can be cast into three categories: whitebox, blackbox, and greybox [34]–[36]. Put succinctly, blackbox test- ing conducts fuzzing without knowing any internal structure of the target program. In contrast, whitebox testing performs fuzzing while having full knowledge about the internal archi- tecture of the target program. Greybox fuzzing stands in the middle of blackbox fuzzing and whitebox fuzzing, where we have partial knowledge of the internal structure of the target program. Particularly, greybox fuzzing can be further divided into two groups. One spectrum of works [37], [38] aim at covering as many paths or branches as possible, expecting to reveal a bug in the program, namely coverage-guided greybox fuzzing. AFL, one of the most well-known fuzzers, employs the lightweight instrumentation technique and genetic algorithm to improve coverage [39]. Some other researchers [16], [40] increase code coverage by smartly selecting and mutating test cases. Typically, these methods improve coverage by generating as many new test cases as possible to traverse previously uncovered program paths. Another spectrum of works [35], [37], [41] are designed to direct greybox fuzzing towards a set of speciﬁc target locations, termed targeted greybox fuzzing. There is a number of greybox fuzzers that focus on speciﬁc program locations, e.g., low-frequency or uncovered branches. For example, [19] utilizes a power schedule to collect feedback information and steer fuzzing towards target locations. AFLGo [35] calculates the distance between entry points and buggy code in the control ﬂow graph, guiding seed mutation to cover the target locations. Overall, targeted greybox fuzzing generates test cases to reach certain target locations, attempting to further trigger a bug. III. MOTIVATING EXAMPLE As a motivating example, we present a real world smart contract GuessNum, which implements a gambling game on contract GuessNum { mapping ( address => uint256 ) userBalance; uint256 prizePool ; constructor () payable { prizePool = msg.value ; } / * Initialize the prize pool * / function guess( uint256 num) payable external { uint256 luckyNum = uint256 (keccak256(abi.encodePacked( block.difficulty , now ))); / * Generate a lucky number * / luckyNum = luckyNum % 100; prizePool = SafeAdd ( prizePool , msg.value ); / * Put funds into the prize pool * / if ( num == luckyNum && msg.value == 50 finney ) { / * If a player guesses it, he obtains 40 times the participant fee * / userBalance [ msg.sender ] = SafeAdd( userBalance [ msg.sender ], msg.value *40) ; } } function getReward() payable external { if ( userBalance[ msg.sender ] < prizePool && userBalance[ msg.sender ] > 0 ) { msg . sender . call . value (userBalance[ msg.sender ])(); / * Reentrancy bug * / prizePool = SafeSub ( prizePool , userBalance[ msg.sender ] ); userBalance[ msg.sender ] = 0 ; } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 Fig. 1 A real-world smart contract written in Solidity. Ethereum [4]. Fig. 1 shows the simpliﬁed code2 of GuessNum, which is written in Solidity. The contract realizes a guess number game that users play by submitting their guesses along with participation fees. The fee is ﬁxed to 50 ﬁnney each time and is poured into the prize pool, i.e., prizePool. Function constructor() runs only once when the contract is created, and it puts the funds of the contract’s owner into the prize pool. A player who wants to submit a guess can invoke function guess(), which compares the received guess number with the randomly generated lucky number, i.e., luckyNum (line 11). If guess number exactly matches the luckyNum, the player will obtain 40 times the participation fee in return (line 13). Players can get rewards by calling function getReward(). Vulnerability. This GuessNum contract, unfortunately, suffers from a classical reentrancy vulnerability. From line 18 of Fig. 1, we observe that function getReward() invokes call.value to transfer money to the user. However, due to the default settings of smart contracts, the transfer operation will automatically trigger the fallback function of the recipient contract. Therefore, an attacker may set a malicious second- time invocation to getReward() in his fallback function for stealing extra money. Since getReward() waits for the ﬁrst-time transfer to ﬁnish, the balance of the attacker is not reduced yet (i.e., the user balance reduction operation at line 19 is behind call.value and is not executed yet). Function getReward() thus may wrongly believe that the attacker still has enough balance and transfers money to the attacker again. Limitation of Existing Fuzzers. Interestingly, this simple smart contract reveals three key challenges for most existing fuzzers to expose vulnerabilities. (1) The order of function invocations is critical. We observe that if the conditions at line 11 are not satisﬁed (namely the then-branch at line 13 is not reached), then the second condition at line 17 will never be met either (because userbalance[msg.sender] is equal to 2Address: 0xd5e94f6350c7911015dd120b0b006420b6e85a58 IEEE TRANSACTIONS ON INFORMATION FORENSICS AND SECURITY 4 Sequence Generation Source Code .Json File Compile Data Flow Analysis Seed Evolution Sequence Prolongation Seed Selection and Mutation Bug R eport Fuzzing Execution Results Branch Analysis Customized Energy Schedule Source Code Analysis Ene rgy Allocation V ulnerability Analysis & Report - Function Invocation Sequence - New T est Cases Branch Distance Measure T echnique - High-Quality Test Suite Target Location - Rare Branches - V ulnerable Branches - Feedback Result Security V ulnerability Patterns - T SIn v ocation - T SContaminate - T SR andom - ... - Initial T est Cases Order Fig. 2 A high-level overview of IR-Fuzz. IR-Fuzz has four main components, including (1) Sequence Generation, (2) Seed Optimization, (3) Energy Allocation, and (4) Vulnerability Analysis and Report. 0). As such, the fuzzer will be unable to reach the then- branch at lines 18–20. (2) Generating a test case to satisfy the second condition at line 11 (msg.value == 50 ﬁnney) is difﬁcult. More speciﬁcally, the variable msg.value has a size of 32 bytes. Thus, when we generate a random value for msg.value in fuzzing, we have only 1 2256 probability to obtain the value 50 to meet the condition. Indeed, existing fuzzers like AFL [39] are shown to have difﬁculties in electing a test case to enter the then-branch at line 13. (3) Vulnerable branches that may contain vulnerabilities only take a small fraction of the program. For example, lines 18–20 are vulnerable code which only exists in one branch. Current fuzzers [22], [23] tend to treat each branch equally, which may fail to discover the vulnerability due to insufﬁcient fuzzing resource allocation. Fuzzing Policy. We embrace three key designs in IR- Fuzz to tackle the challenges. (1) IR-Fuzz leverages the variable read and write dependencies between functions to generate the ordered function invocation sequence. It further extends the ordered sequence with another ordered sequence to explore more complex states. Speciﬁcally, this contract (Fig. 1) has two global variables, i.e., userBalance and prizePool, which both appear in functions guess() and getReward(). By analyzing read and write dependencies of the global variable userBalance, IR-Fuzz recognizes that function getReward() depends on function guess(), awaring that guess() should be called before getReward(). Consequently, IR-Fuzz generates the function invocation sequence as: guess()→getReward(). (2) IR-Fuzz adopts a branch distance-based schema to select test cases according to how far a test case is from satisfying the condition of a just-missed branch. For example, the distance of reaching the just-missed branch (i.e., then-branch at line 13) is calculated as |msg.value - 50| since the branch condition at line 11 is msg.value == 50. Intuitively, the test case has a higher probability to enter the just-missed branch as the distance decreases. With the guidance of distance measure, IR- Fuzz iteratively evolves test cases to get increasingly closer to satisfying the branch condition at line 11. (3) IR-Fuzz engages a branch search algorithm to pick out vulnerable (e.g., then- branch at lines 18–20) and rare branches, and then formulates an energy schedule to expend more fuzzing resources on these important branches. In our experiments, after only 26s, IR- Fuzz generates a test case to reach the then-branch at line 18 and exposes the reentrancy vulnerability. IV. METHOD Overview. The overall architecture of IR-Fuzz is outlined in Fig. 2. Generally, IR-Fuzz consists of four key components: • Sequence Generation: Given that a contract might contain multiple functions, to explore their possible function in- vocation sequences, IR-Fuzz ﬁrst analyzes the data ﬂow dependencies between functions. Then, it deﬁnes a rule to compute the order priority of each function, and generates a function invocation sequence that successively calls the ordered functions. Further, IR-Fuzz adopts a prolongation technique to extend the sequence, driving the fuzzer to dive into deeper states. • Seed Evolution: To guide seed mutation so that the gen- erated cases could reach a target branch, IR-Fuzz utilizes a branch distance-based measure to select and evolve test cases iteratively according to how far a test case is from satisfying the condition of the target branch. • Energy Allocation: To further take care of the rare branches and branches that are likely to have vulnerabilities, IR-Fuzz introduces a branch search algorithm to analyze exercised branches and picks out those important branches. Then, IR- Fuzz formulates a customized energy schedule and utilizes two rules to ﬂexibly guide fuzzing energy allocation towards these critical branches. • Vulnerability Analysis and Report: IR-Fuzz analyzes the generated logs and refers to vulnerability-speciﬁc patterns to discover vulnerabilities. Bug reports are generated for further manual inspections. In what follows, we will elaborate on the details of these components one by one. A. Sequence Generation Presented with the multiple functions of a smart contract, existing methods tend to generate a function invocation se- quence by randomly picking a function each time. Scrutinizing 12K real-world smart contracts, we empirically observe that the state of a smart contract is often captured by the state of its global variables, and different functions do share and operate differently on the global variables. Some functions IEEE TRANSACTIONS ON INFORMATION FORENSICS AND SECURITY 5 perform ‘read’ operations on the variables while some other functions may perform ‘write’ operations on the variables. Generating function invocation sequence randomly ignores such connections between functions. The functions that per- form ‘write’ operations could change the state of the contract while the functions that perform only ‘read’ operations are unable to change the state. Therefore, we assign higher order priority to functions that perform ‘write’ operations so that we may explore a broader contract state space and cover more branches. It is worth mentioning that initializing a variable will not affect the method. Sequence Ordering. Motivated by this, we propose to model the global variable read and write dependencies be- tween functions. Speciﬁcally, we ﬁrst characterize the source code of a smart contract into an abstract syntax tree [42], from which we extract variable access operations such as assignments and comparisons. Then, we leverage a data ﬂow analyzer to capture the read and write dependencies of global variables between functions. Afterwards, we calculate the order priority (OP) of each function and sort them according to their OPs. Finally, we generate the ordered function invocation sequence, i.e., the invocation sequence that calls the sorted functions successively. Formally, we denote the set of functions in a smart contract as F = {F1, F2, ..., FN }, and global variables that appear in function Fi as V = {vi1, vi2, ..., viM }, where M is the number of global variables appear in Fi and vik represents the k-th global variable in Fi. Speciﬁcally, each variable vik has a unique identiﬁer (i.e., variable name), which is denoted as vID ik . To further indicate the operation that Fi exerted on vik, we use vop ik = 1 to represent that Fi performs read operation on vik, and vop ik = 0 to denote that Fi conducts write operation. Now, we deﬁne the order priority of functions as below. Rule 1: Read & Write Dependency. When a global variable appears in two different functions, the function that executes write operation on the variable should be called earlier than the function that executes read operation. Put differently, given global variables vik in Fi and vjn in Fj (where vID ik = vID jn ), we suggest that Fi should have a higher order priority (OPFi > OPFj ) when vop ik = 0 and vop jn = 1. Guided by this, we may compute the order priority of each function by converting this rule into the following formula, which sums up the analysis on read & write dependencies (Rule 1) of all global variables in different functions. OPi = Mi∑ k=1 Mj∑ p=1 vop jp (1 − vop ik ) · cmp(vik, vjp) 1 ≤ i, j ≤ N && i ̸= j (1) where N is the number of functions in the contract. Mi and Mj denotes the number of the appearance of global variables in Fi and Fj, respectively. Notably, cmp(vik, vjp) compares the identiﬁer of global variables in two different functions, which is given by: cmp(vik, vjp) = { 1, vID ik = vID jp 0, vID ik ̸= vID jp (2) where vik denotes k-th variable of Fi and vjp represents p-th variable of Fj. Mathematically, in Eq.(1), a function accumulates one order priority score only if it writes on a global variable and the variable is read by another function. In this context, the functions that conduct write operations on more global variables get higher priority and are put in the front of the function invocation sequence. This drives the fuzzer to exercise more on the functions that could change the states and boost the fuzzing by encouraging it to encounter more states and reach more branches. Interestingly, our experimental results show that branch coverage is signiﬁcantly improved with such sequence ordering (see §V-E). Here, we take the contract of Fig. 1 as an example to illustrate the order priority calculation of each function. From Fig. 1, we can observe that this contract has two global variables, i.e., userBalance and prizePool. Function guess() performs a read operation and a write operation on the two variables, respectively. We represent the variables that appear in function guess() as Vguess = {vguess1, vguess2, vguess3, vguess4}, where vguess1 = vguess2 = prizePool, vop guess1 = 1, vop guess2 = 0, and vguess3 = vguess4 = userBalance, vop guess3 = 1, vop guess4 = 0. Meanwhile, cmp(userBalance, prizePool) = 0, while cmp(userBalance, userBalance) = cmp(prizePool, prizePool) = 1. Similarly, the global variables appear in getReward() are denoted as VgetReward = {vgetReward1, vgetReward2, ..., vgetReward8}, where vop getReward1 = ... = vop getReward6 = 1, and vop getReward7 = vop getReward8 = 0. As such, according to Eq.(1), we calculate the order priority of function guess() as below. OPguess =vop getReward1(1 − vop guess4) + vop getReward2(1 − vop guess2) +vop getReward3(1 − vop guess4) + vop getReward4(1 − vop guess4) +vop getReward5(1 − vop guess2) + vop getReward6(1 − vop guess4) =6 (3) For function getReward(), we calculate its order priority as: OPgetReward =vop guess1(1 − vop getReward7) +vop guess3(1 − vop getReward8) =2 (4) According to the order priority calculation, we can see that the order priority of calling function guess() is greater than that of function getReward(). Therefore, IR-Fuzz ﬁnally generates the function invocation sequence as: guess() → getReward(). Sequence Prolongation. Another important insight is that a smart contract might go through many different states dur- ing its lifecycle. However, current methods typically conduct fuzzing starting from the initial state of the contract, which expends too much energy revolving around the initial state and is usually incapable of unearthing bugs triggered by other states. These facts inspire us to explore richer starting states via sequence prolongation. Particularly, we ﬁrst exercise the ordered function invocation sequence S using various test cases, which result in different states of the contract. We then engage in the invocation sequence S again but execute S starting from these different states, i.e., appending a new sequence S after S. For instance, presented with the crowdfunding contract in Fig. 3, we observe that covering the if-branch at line 21 for traditional fuzzers is difﬁcult, which requires at least twice IEEE TRANSACTIONS ON INFORMATION FORENSICS AND SECURITY 6 contract CrowdFunding { uint256 goal; uint256 raised; uint256 phase; address beneficiary ; constructor () { beneficiary = msg.sender ; goal = 300 ether ; raised = 0; phase = 0; } / * 0 : Active 1: Finished * / function donate ( uint256 donations ) payable public { / * Check if the crowdfunding goal is reached * / if (raised < goal ) { raised += donations ; } else { phase = 1; } } function withdraw () public { / * The crowdfunding goal has been reached * / if (phase == 1 ) { beneficiary . delegatecall (bytes4(keccak256(“transfer(uint256)”)), r aised ); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 Fig. 3 An example contract for illustrating how the sequence prolongation technique is used in IR-Fuzz. invocations of function donate(). Particularly, this contract implements a simple crowdfunding project that allows users to donate money by calling donate(). The constructor() sets the goal of crowdfunding as 300 Ether (line 9), and the raised money is initialized to 0 (i.e., raised = 0 at line 10). The status of the crowdfunding process is initialized to 0 (i.e., phase = 0 at line 11), which represents unaccomplished. According to Rule 1, we realize that the invocation to func- tion donate() should have a higher order priority than that of function withdraw(). As a result, the function invocation sequence is generated as: donate()→ withdraw(). However, such a sequence fails to satisfy the branch condition at line 21 because call function donate() once cannot enter the else- branch at line 16 to set phase = 1. To reach the else-branch at line 16, function donate() needs to be called at least twice. Namely, the required amount of money for the crowdfunding is accomplished at the ﬁrst call (i.e., raised ≥ goal), and the second call enters the else-branch at line 16. Therefore, to explore deeper states, we propose to prolong the function invocation sequence. In contrast to most fuzzing methods that conventionally call each function only once in the invocation sequence, we further extend the ordered function invocation sequence S by appending the same invocation sequence to S, namely S → S, such that the second sequence starts its execution from a different state rather than the initial state. To explore different starting states for the second sequence, the ﬁrst sequence is presented with different sets of parameters, which lead to different inner statuses. Technically, we ﬁrst try to sufﬁciently exercise sequence S with various different input parameters. A different set of input parameters to S translates to a variant of S, denoted as Sj. Then, we concatenate two sequences Si and Sj that have different input parameters and exercise the new concatenated sequence. The following rule formulates the Algorithm 1: SEED ITERATIVE OPTIMIZATION 1 currentT estSuite ← ∅; 2 currentT estCase ← initialT estCase(); 3 while ¬T erminated() do 4 Let BtestCase be covered branches by currentT estCase; 5 Let Bmiss be just-missed branches in currentT estSuite; 6 for br ∈ BtestCase do 7 if br is new branch then 8 currentT estSuite.ADD(currentT estCase); 9 for br ∈ Bmiss do 10 for seed ∈ currentT estSuite && seed ̸= currentT estCase do 11 dist_1 ← distance(currentT estCase, br); 12 dist_2 ← distance(seed, br); 13 if dist_1 < dist_2 then 14 currentT estSuite.REMOVE(seed); 15 currentT estSuite.ADD(currentT estCase); 16 energy ← 0; 17 M utationEnergy ← AssignM utationEnergy(); 18 while energy < M utationEnergy do 19 testCase ← SelectInput(currentT estSuite); 20 newCase ← M utation(testCase); 21 if ¬RepeatCheck(currentT estSuite, newCase) && ¬V alidityCheck(newCase) then 22 currentT estCase.ADD(newCase); 23 log ← F uzzInput(newCase); 24 energy ← U pdateEnergy(log, energy); 25 return currentT estSuite: A set of high-quality test cases sequence pair selection to generate a new prolonged sequence, which constrains that the input parameters of Si and Sj should be quite different. Rule 2: Sequence Pair Selection. (1) When the number of required function input parameters in the sequence is no less than 2, we select the sequence pairs iff at least one input paramter is different between the two sequences. For example, given three sequences S1: F1(x1) → F2(), S2: F1(x2) → F2(), and S3: F1(x2) → F2(), pairs P1(S1, S2) and P2(S1, S3) are selected. In contrast, pair P3(S2, S3) is not selected since S2 and S3 have the same parameters. (2) When the number of required function input parameters is larger than 2, we select the sequence pairs iff at least two input parameters are different between the two sequences. For example, given three sequences S1: F1(x1, y1) → F2(z1), S2: F1(x1, y2) → F2(z1), and S3: F1(x2, y2) → F2(z2), pairs P1(S1, S3) and P2(S2, S3) are selected. Upon each sequence pair selection, we obtain a prolonged function invocation sequence. For the crowdfunding contract demonstrated in Fig. 3, IR-Fuzz ﬁrst generates two sequences, e.g., S1: donate(300) → withdraw() and S2: donate(200) → withdraw(). According to Rule 2, IR-Fuzz combines S1 and S2 as a new prolonged sequence S: donate(300) → withdraw()→ donate(200) → withdraw(). Since the goal of crowdfunding is 300, the ﬁrst call to donate(300) in S satisﬁes the condition of the if-branch at line 15, and the second call to donate(200) reaches the else-branch at line 16 (i.e., set phase = 1). The new sequence thus can reach the then-branch at line 22 on the IEEE TRANSACTIONS ON INFORMATION FORENSICS AND SECURITY 7 second call to withdraw() and expose the potential Ether frozen vulnerability. Promisingly, with the prolongation technique, IR-Fuzz greatly expands the scope of explored states and branches. Note that the sequence prolongation technique yields little impact on the overhead of the fuzzer. B. Seed Evolution To fuzz a function invocation sequence, the most intuitive and direct way is to generate test cases randomly. Despite its simplicity, this strategy is not favorable for reaching unex- plored conditional branches due to its random nature. IR-Fuzz, instead, incorporates a seed evolution paradigm to reﬁne test cases iteratively. The seed evolution framework is summarized in Algorithm 1. First, IR-Fuzz initializes an empty test suite and a set of test cases (lines 1-2). Then, the ﬁrst loop from lines 6 to 8 performs seed selection. Whenever a test case covers a new branch (i.e., any branch not covered by test cases in the test suite), it is added to the suite. Next, the loop from lines 9 to 15 evolves test cases iteratively. Particularly, we propose a branch distance-based measure to select those test cases which are closer to satisfying the conditions of new branches. Thereafter, the loop from lines 18 to 24 executes seed mutation, in which function Mutation() generates the mutated test cases based on the test cases selected from the suite (lines 19-20). Then, we adopt seed veriﬁcation strategies to guarantee the validity of mutated test cases (line 21). This mutation process continues until a mutation energy upper- bound is reached (line 18). Finally, a new test suite that contains a set of high-quality test cases is shaped. In what follows, we present the technical details of seed selection and seed mutation, respectively. Seed Selection. In IR-Fuzz, we ﬁrst try a classical seed selection strategy. That is, IR-Fuzz monitors the execution of test cases and records the branches that each test case traverses. A test case is added into the test suite as long as it covers a new branch, i.e., a branch which is not covered by any test case in the suite. Empirically, our experimental results show that this strategy could reveal a number of branches. However, it is still quite inefﬁcient in reaching those complex branches with strict conditions. For example, the probability of satisfying the second condition (msg.value == 50 ﬁnney) at line 11 of Fig. 1 is 1 2256 , which is extremely low. To meet such strict branch conditions, we design a novel seed selection strategy. Inspired by [16], we adopt a distance function dist(T, br) to compute a branch distance indicating how far a test case is from covering a just-missed branch (i.e., uncovered then- branch). More speciﬁcally, let br be a just-missed branch, which is not covered by any test case T . We suppose that br is a branch of condition C. Note that C can be either x==k, x! = k, x ≤ k, x < k, x ≥ k or x > k, where x and k are variables or constants. The function dist(T, br) is given by: dist(T, br) =  ||| ||| |x − k|, if C is x == k 1, if C is x ! = k max(x − k, 0) if C is x ≤ k or x < k max(k − x, 0) if C is x ≥ k or x > k (5) where x and k are extracted from the stack information recorded by IR-Fuzz. Intuitively, dist(T, br) is deﬁned such Algorithm 2: BRANCH SEARCHING Input: Program P, Test case case, Vulnerable statements T Output: Brare and Bvulnerable 1 br ← F uzzRun(P, case); 2 Brare ← ∅; // Rare Branches 3 Bvulnerable ← ∅; // Vulnerable Branches 4 R ← 0; 5 i ← 0; 6 while i < |br| do 7 if IsConditionInstruction(i, Cb) then 8 R ← R + 1, bpre ← br[0...i + 1]; 9 c, state ← StateInf erence(bpre); 10 if V ulnerableStatementReached(P, state, c, T ) then 11 Bvulnerable.ADD(br); 12 i ← i + 1; 13 if R ⩾ 2 then 14 Brare.ADD(br); that the closer a test case T is from satisfying the condition of branch br, the smaller the distance is. For example, a test case with msg.value = 100 is closer to satisfying the condition msg.value == 50 than a test case with msg.value = 10,000. For each just-missed branch, IR-Fuzz selects a test case has the smallest dist(T, br). With the feedback of the branch distance measurement, IR-Fuzz can quickly approach complex branches guarded by strict conditions, improving the overall branch coverage. Note that all selected test cases are added to the test suite and transferred to the seed mutation phase for generating new test cases. Seed Mutation. Seed mutation plays an important role in enriching the test cases. In IR-Fuzz, we refer to several mutation strategies from AFL and introduce new ones tailored for smart contracts. Particularly, we preferentially mutate those test cases with smaller branch distances. Given a test case encoded in the form of a bit vector, sFuzz [16] engages a set of mutation operators to generate new test cases, such as bit ﬂipping, interest value insertion, and key-value insertion. IR-Fuzz additionally ensures the generated test cases are valid by advocating two principles. (1) IR-Fuzz checks the validity and integrity of the mutated test cases by using a bit veriﬁcation approach, which sets random bits of a given seed to random values while keeping other bits of the seed unchanged. Thereafter, IR-Fuzz saves a new test case as a new seed based on whether the new test case detects a new branch. Moreover, IR-Fuzz will discard invalid test cases which lead to fuzzing crashes or bring much overhead to the fuzzer. (2) IR-Fuzz removes duplicate test cases by comparing the mutated cases with the test cases in the test suite. In practice, we also apply multiple heuristics to save the mutation energy of IR-Fuzz. For example, any test case in the test suite that does not discover a new branch after a round of mutation will be assigned with low priority in the mutation. IR-Fuzz updates energy according to the generated logs during fuzzing (lines 23-24 in Algorithm 1). The process of seed mutation continues until the mutation energy upper-bound is reached. Each seed is assigned with a priority score which measures its ability to detect new branches after mutations. IEEE TRANSACTIONS ON INFORMATION FORENSICS AND SECURITY 8 contract Cheer { uint256 num = 0; function random ( uint256 x, uint256 y, uint256 z ) returns ( uint256 ) { if (x % 2 == 0 ) { num = 256; while (x != z) { num = SafeMul( x, z); if (x > z) { z = SafeAdd (z, z) ; } else { x = SafeAdd(x, x) ; } } if (y % 2 == 0 ) { num = uint256 (keccak256(abi.encodePacked( block .number , now ))); / * Block number dependency * / } } else { num = 3; } return num; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Fig. 4 An example contract for illustrating how IR-Fuzz allocates energy to the target branches ﬂexibly. C. Energy Allocation In this subsection, we introduce how IR-Fuzz performs fuzzing energy allocation. Recall that most existing fuzzers treat program branches equally, ignoring the fact that vulner- able code usually takes a tiny fraction of the entire code [18], [43]. As a result, conventional fuzzers may waste massive resources in fuzzing normal branches instead of rare branches and branches that are more likely to possess bugs. To tackle this problem, we design an energy allocation mechanism, guiding IR-Fuzz to assign fuzzing resources towards these important branches. Speciﬁcally, this mechanism consists of two modules: branch analysis and energy schedule. Branch Analysis. We remark that the ﬁrst challenge is how to pick out the important branches. To address this, we introduce a branch search algorithm to analyze all branches discovered during fuzzing and focus on two types of branches: rare and vulnerable, which are deﬁned as follows. Deﬁnition 1 (Branch): Given a path p exercised by a test case in smart contract S, we say that br is a preﬁx subpath of p if br is a subpath of p and br begins with the same starting point as p. Further, br is a branch of p if br is a preﬁx subpath of p and br ends with the if-branch or then-branch of a conditional or recurrent statement (e.g., if, require, for, while) in S. Deﬁnition 2 (Rare Branch): We consider a branch br is a rare branch if br contains at least two nested conditional statements (e.g, two nested if). Each rare branch is associated with a rarity factor R, which is set to the number of nested conditional statements (at the end of this branch). Deﬁnition 3 (Vulnerable Branch): Given a branch br and a set of vulnerable statements T that may introduce bugs (e.g., block.number and call.value), we say that br is a vulnerable branch when br contains a vulnerable statement t ∈ T . After empirically scrutinizing real-world smart contracts, we found that over 50% (65% and 86% in our experiments) of bugs are located in rare and vulnerable branches. To pick out the two types of branches, we design a branch analysis algorithm shown in Algorithm 2. Technically, IR-Fuzz employs the abstract interpreter A to pick out the important branches. First, A analyzes all branches Br discovered during fuzzing (line 1). Then, the loop from lines 6 to 12 checks whether there exists a branch br that reaches the vulnerable statement t ∈ T and computes the rarity factor R for each branch. Afterwards, A adds the branches with R ⩾ 2 into Brare (lines 13-14). Finally, A obtains a set of rare branches Brare and vulnerable branches Bvulnerable. Energy Schedule. We remark that the second challenge is how to assign resources to these important branches. Towards this aim, we formulate a customized energy schedule Ω to manage the fuzzing energy allocation. This schedule adopts two rules for rare and vulnerable branches, respectively. Rule 3: Energy Allocation for Rare Branches. Given branches br1 with R1 and br2 with R2 in a same path p, where Ri is rarity factor and R1 < R2. To facilitate that rare branches with higher rarity factors are more sufﬁciently fuzzed, Ω assigns energy ∇1 ∗E to br1 and ∇2 ∗E to br2 where ∇1 < ∇2. Rule 4: Energy Allocation for Vulnerable Branches. Given a branch br1 in a path p1 and a branch br2 in a path p2, Ω assigns α ∗ E energy to br1 (α > 1) and E energy to br2 when R1 = R2 and br1 ∈ Bvulnerable. Coefﬁcient α controls the preference degree for vulnerable branches. We use the example of Fig. 4 to show how IR-Fuzz works with the energy allocation mechanism. Speciﬁcally, IR-Fuzz ﬁrst analyzes all discovered branches and picks out br at line 12 as the vulnerable branch since it contains a vulner- able statement (i.e., block.number) at line 13. Then, IR-Fuzz calculates the rarity factor R of this branch, where R = 2. As a result, IR-Fuzz assigns energy (α + ∇) ∗ E to branch br, according to Rule 3 and Rule 4. In our experiments, an interesting observation is that state-of-the-art tools like sFuzz cannot reach the if-branch at line 12 since they waste too much energy in fuzzing the while branch at line 7. In contrast, IR- Fuzz successfully covers this branch and exposes the block number dependency vulnerability at line 13 in 8s on average (between 4s and 12s in 5 runs). Moreover, IR-Fuzz also utilizes the feedback of energy allocation to guide seed mutation. For example, the test cases which cover the vulnerable branches will be selected and fuzzed ﬁrst. Inspiringly, with the energy allocation mechanism, IR-Fuzz can ﬂexibly assign fuzzing resources to the rare and vulnerable branches, increasing overall fuzzing efﬁciency and branch coverage. D. Vulnerability Analysis and Report In this stage, IR-Fuzz turns to vulnerability analysis and report generation, which reveals vulnerabilities in smart con- tracts and generates a detailed bug report for further manual conﬁrmation. In particular, we investigate previous works (e.g., [2], [20], [44]) and deﬁne the speciﬁc patterns for eight types of vulnerabilities, namely timestamp dependency, block number dependency, dangerous delegatecall, Ether frozen, IEEE TRANSACTIONS ON INFORMATION FORENSICS AND SECURITY 9 Execution & Analyze Execution & Analyze Smart Contract Generate compiled JSON file Seed selection with branch-distance-based feedback Branch energy allocation Seed mutation with energy-allocation-based feedback Bug r eports Data flow dependency Function invocation sequence Seed Selection & Mutation V ulnerability analysis and r eport Seed evolution Generate function invocation sequence b 1 b 2 b n 1.{ 2. bytecode:{ 3. ... 4. } ； 5. abi:{ 6. ... 7. }; 8. ... 9.} 1 1 4 1 ... b 1 b 2 b n 2 3 2 k - 1 k Rar e V ulnerable b 1 : e 1 b 2 : e 2 ... b n : e n b x : e m a x s x (seed of b x ) 1 2 3 45 6 1 2 3 4 k k-1 ... Energy schedule Branch Energy b 1 e 1 ... b n e n Abstract syntax tr ee Compile guess() getReward() T est Suite Log information V ulnerability-specific patterns Log - CALL - ... Branch analysis Order T est Case T est Case Fig. 5 The workﬂow of IR-Fuzz to reveal the reentrancy vulnerability in the real-world contract of Fig. 1. unchecked external call, reentrancy, integer overﬂow, and dan- gerous Ether strict equality. We have implemented a pattern analyzer to handle these patterns. IR-Fuzz analyzes the fuzzing results and reveals bugs with the assistance of the pattern analyzer. In the following, we show an example of how IR- Fuzz exposes a reentrancy vulnerability using patterns. Vulnerability Pattern Example. Reentrancy vulnerability is considered as an invocation to call.value that can call back to itself through a chain of calls. That is, the in- vocation of call.value is successfully re-entered to perform unexpected repeat money transfers. Speciﬁcally, we design two patterns to expose the reentrancy vulnerability. The ﬁrst pattern CALLValueInvocation checks if there exists an in- vocation to call.value in the contract. The second pattern RepeatedCallValue concerns whether a speciﬁc function with call.value invocation is called repeatedly during fuzzing. IR- Fuzz reports that a function has a reentrancy vulnerability if it fulﬁlls the combined pattern: CALLValueInvocation ∧ RepeatedCallValue. E. IR-Fuzz Workﬂow Illustration with an Example In this subsection, we take the contract of Fig. 1 as an example to show the workﬂow of IR-Fuzz on revealing a reentrancy vulnerability. The workﬂow consists of six steps, illustrated in Fig. 5. Given the contract with source code as input, IR-Fuzz ﬁrst compiles the source code to the JSON ﬁle, which consists of EVM bytecode and application binary interface (ABI) (¶ in Fig. 5). Second, IR-Fuzz extracts the abstract syntax tree and captures the data ﬂow dependencies of global variables. By analyzing these dependencies, IR- Fuzz infers the function invocation sequence as: guess() → getReward() (· in Fig. 5). Thirdly, IR-Fuzz generates test cases for the two function calls and adds high-quality test cases into the test suite based on the branch distance-based measure. As such, IR-Fuzz effectively generates test cases to cover new branches (¸ in Fig. 5). Furthermore, IR-Fuzz performs the branch analysis to pick out the important branches. Then, it customizes an energy schedule to assign fuzzing resources (¹ in Fig. 5). IR-Fuzz utilizes the feedback of energy allocation to guide seed selection and mutation. After several rounds of fuzzing, IR-Fuzz reaches the then-branch at line 18 and triggers the execution of the transfer function (i.e., call.value). We develop an attack contract generator, which simulates an attack contract that calls the transfer function getReward() again. IR-Fuzz records the instructions into a log ﬁle (º in Fig. 5). Finally, IR-Fuzz analyzes the log and determines whether the call.value was called multiple times, exposing the reentrancy vulnerability with the assistance of vulnerability- speciﬁc patterns (» in Fig. 5). Besides fuzzing the ordered invocation sequence, IR-Fuzz further prolongs the sequence to explore other complex states. V. EXPERIMENTS In this section, we conduct extensive experiments to evaluate IR-Fuzz, seeking to address the following research questions. • RQ1: Can IR-Fuzz effectively detect contract vulnerabili- ties? How is its performance against state-of-the-art tools? • RQ2: Does IR-Fuzz achieve higher branch coverage than existing methods? • RQ3: How efﬁcient is IR-Fuzz in fuzzing smart contracts and generating test cases compared with other fuzzers? • RQ4: How much do different components of IR-Fuzz contribute to its performance in branch coverage and vul- nerability detection accuracy? We ﬁrst introduce the experimental settings, then proceed to answer the above questions. We also present a case study to allow for a better understanding of the proposed approach. A. Experimental Setup Implementation. IR-Fuzz in total contains 9K+ lines of C++ code, which is released for public use at https://github. com/Messi-Q/IR-Fuzz . We implemented IR-Fuzz on the basis of sFuzz [16] (a state-of-the-art smart contract fuzzer). Baselines. In the experiments, we include seven open- source methods that either have a high number of citations IEEE TRANSACTIONS ON INFORMATION FORENSICS AND SECURITY 10 TABLE I Summary of vulnerability types supported by state-of-the-art methods. TP is short for timestamp de- pendency; BN represents block number dependency; DG represents dangerous delegatecall; EF represents Ether frozen; UC represents unchecked external call; RE rep- resents reentrancy; OF represents integer overﬂow; SE represents dangerous Ether strict equality. Methods V ulnerability T ype #Citation or #GitHub Stars Publication TP BN DG EF UC RE OF SE Oyente [15] ✓ ✓ ✓ 1,780 citations CCS’16 Osiris [45] ✓ ✓ ✓ 182 citations A CSA C’18 Securify [31] ✓ ✓ ✓ 604 citations CCS’18 ILF [22] ✓ ✓ ✓ ✓ 105 citations CCS’19 sFuzz [16] ✓ ✓ ✓ ✓ ✓ ✓ ✓ 91 citations ICSE’20 Mythril [46] ✓ ✓ ✓ ✓ 2,900 GitHub stars White P aper ConFuzzius [23] ✓ ✓ ✓ ✓ ✓ ✓ 45 GitHub stars EuroS&P’21 IR-Fuzz ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ – – or receive many stars in GitHub. The methods are summa- rized in Table I, where we illustrate the vulnerability types that they can detect, their numbers of citations or GitHub stars, and their publication information. For fuzzing tools, we select ConFuzzius [23], ILF [22], and sFuzz [16], which achieve state-of-the-art performance and support at least four vulnerability types on smart contracts. For static analysis tools, we select Mythril [46], Oyente [15], Osiris [45], and Securify [31], which are well-known vulnerability checkers for smart contracts. We compare IR-Fuzz with them in terms of branch coverage, effectiveness, and efﬁciency. All experiments are conducted on a computer equipped with an Intel Core i9 CPU at 3.3GHz, a GPU at 2080Ti, and 64GB Memory. Each experiment is repeated ten times, we report the average results. Dataset. We obtain the dataset by crawling Etherscan [47] veriﬁed contracts, which are real-world smart contracts de- ployed on Ethereum Mainnet. In practice, we removed 5,074 duplicate contracts by comparing the hash of the contract bi- nary code. Our ﬁnal dataset contains a total 12,515 smart con- tacts that have source code. As listed in Table I, we focus on eight types of vulnerabilities in the dataset, namely timestamp dependency (TP), block number dependency (BN), dangerous delegatecall (DG), Ether frozen (EF), unchecked external call (UC), reentrancy (RE), integer overﬂow (OF), and dangerous Ether strict equality (SE). We deployed all smart contacts of the dataset to a local Ethereum test network for experiments. For the ground truth labels of smart contracts, we deﬁne vulnerability-speciﬁc patterns for each kind of vulnerability to give a preliminary label and then manually check whether a smart contract in the dataset indeed has a certain vulnerability. In particular, using the deﬁned vulnerability-speciﬁc patterns (e.g., keyword matching), we could ﬁnd smart contracts that may have vulnerabilities and save our time on labeling those contracts that are safe (e.g., a contract with no ‘call.value’ invocation will not have reentrancy vulnerabilities). B. Effectiveness (RQ1) First, we benchmark IR-Fuzz against existing vulnerability detection methods. We count the number of smart contracts that have vulnerabilities and are identiﬁed by each method, and present the accuracy, true positives, and false positives of each method. Comparing IR-Fuzz to State-of-the-arts. We ﬁrst com- pare IR-Fuzz to other fuzzers and existing static analysis TABLE II Accuracy comparison (%) on different methods, including static analysis tools, fuzzers, and IR-Fuzz. ‘n/a’ denotes that a tool cannot detect the speciﬁc vulnerability. Methods V ulnerability T ype (Accuracy) TP BN DG FE UC RE OF SE Mythril [46] n/a 89.97 70.95 n/a n/a 95.09 89.87 n/a Oyente [15] 86.86 n/a n/a n/a n/a 94.61 74.76 n/a Osiris [45] 86.56 n/a n/a n/a n/a 93.28 74.80 n/a Securify [31] n/a n/a n/a 79.42 91.24 91.52 n/a n/a ILF [22] n/a 87.53 80.99 78.65 94.71 n/a n/a n/a sFuzz [16] 87.25 88.37 83.33 83.85 94.26 95.20 89.98 n/a ConFuzzius [23] n/a 87.70 80.47 78.91 94.68 93.33 77.35 n/a IR-Fuzz 90.25 94.18 95.33 95.05 98.10 98.77 98.79 99.73 TABLE III True and false positives of each method in identifying the eight types of smart contract vulnerabilities. Methods V ulnerability T ype (T rue / F alse P ositi v es) T otal TP BN DG FE UC RE OF SE Mythril [46] n/a 4/63 20/20 n/a n/a 0/62 10/245 n/a 34 Oyente [15] 12/6 n/a n/a n/a n/a 8/87 16/637 n/a 36 Osiris [45] 4/5 n/a n/a n/a n/a 12/139 12/632 n/a 28 Securify [31] n/a n/a n/a 0/0 7/208 4/194 n/a n/a 11 ILF [22] n/a 0/103 8/4 0/3 5/82 n/a n/a n/a 13 sFuzz [16] 23/8 20/108 20/7 20/3 7/100 10/68 3/235 n/a 103 ConFuzzius [23] n/a 20/120 4/2 0/2 8/86 6/131 10/565 n/a 48 IR-Fuzz 92/5 26/3 58/0 65/0 83/36 95/20 21/10 45/0 485 tools. Quantitative experimental results of each method are summarized in Table II. From the table, we obtain the fol- lowing observations. (1) Compared with other methods, IR- Fuzz is able to identify more vulnerabilities. Inspiringly, IR- Fuzz has achieved a high accuracy (more than 90%) on all eight types of vulnerabilities. (2) IR-Fuzz consistently outperforms state-of-the-art methods by a large margin in detecting each type of vulnerability. For example, for Ether frozen vulnerability (EF), IR-Fuzz gains 15.63% and 16.14% accuracy improvements over Securify and ConFuzzius. These strong empirical evidences suggest the great potential of IR- Fuzz to identify smart contract vulnerabilities. We attribute its superior performance to the key modules proposed, i.e., sequence generation, seed optimization, and energy allocation, which boost the capability of IR-Fuzz in improving branch coverage and hunting vulnerabilities. (3) Promisingly, IR- Fuzz discovers a new kind of smart contract vulnerability, i.e., dangerous Ether strict equality (SE). To the best of our knowledge, this vulnerability cannot yet be detected by current automatic tools. We also present an illustrative case study on how our method detects this vulnerability in §V-F. Analysis of True and False Positives. To further eval- uate the effectiveness of IR-Fuzz, we examine the identiﬁed vulnerable contracts to see whether they are true positives or not. Table III demonstrates the number of vulnerable contracts discovered by each method, as well as the numbers of true positives and false positives of each method. (1) From Ta- ble III, we observe that existing methods have not yet obtained a high true positive rate on the eight types of vulnerabilities. For example, for unchecked external call vulnerability (UC), Securify and sFuzz generate 7 true positives, while ConFuzzius and ILF obtain 8 and 2 true positives, respectively. This is mainly due to the reason that conventional tools ignore handling exceptions for the return value of external calls. (2) Moreover, we also ﬁnd that existing methods have high false positives. For block number dependency vulnerability (BN), fuzzing tools sFuzz, ConFuzzius, and ILF produce IEEE TRANSACTIONS ON INFORMATION FORENSICS AND SECURITY 11 0 10 20 30 40 Time (s) 0 20 40 60 80 100Branch Coverage (%) IR-Fuzz sFuzz ILF ConFuzzius (a) Branch coverage of different meth- ods on small contracts 0 10 20 30 40 Time (s) 0 20 40 60 80 100Branch Coverage (%) IR-Fuzz sFuzz ILF ConFuzzius (b) Branch coverage of different meth- ods on large contracts Fig. 6 Curves comparison: the tendency of branch coverage over time on different fuzzers. over 100 false positives. For integer overﬂow vulnerability (OF), 632, 637, and 565 false positives are reported by Osiris, Oyente, and ConFuzzius, respectively. The high false positives of these methods may stem from two facts: (i) Most methods tend to detect vulnerabilities using a few simple but imprecise patterns, e.g., identifying block number vulnerability by crudely checking whether there is a block.number statement in the function; (ii) Many tools conservatively assume that all arithmetic operations returning a negative value are vulnerable, resulting in high false positives. IR-Fuzz reports more true positives than other methods. For example, for timestamp dependency vulnerability (TP), IR- Fuzz generates 92 true positives, 88, 80, and 69 more than Osiris, Oyente, and sFuzz, respectively. In total, IR-Fuzz ﬁnds vulnerabilities in 485 contracts, roughly 4.7 times more than sFuzz, which ranks the second. For reentrancy vulnerability (RE), IR-Fuzz produces 95 true positives, which signiﬁcantly outperforms the state-of-the-art tool Osiris. More importantly, IR-Fuzz can precisely detect a new kind of vulnerability (SE) without reporting any false positives. We attribute the good performance of IR-Fuzz to the fact that it integrates the three presented new techniques, which are able to supplement each other for precise bug detection. In summary, IR-Fuzz can effectively identify various vulnerabilities in smart contracts, surpassing existing static analysis tools and fuzzers by a large margin. C. Branch Coverage (RQ2) We now present evaluation results on branch coverage of IR-Fuzz. We measure the number of distinct branches covered by the generated test cases in the test suite. Moreover, to examine the branch coverage on contracts with different sizes, we follow the settings of previous work [22] and split the dataset into 1,885 large contracts (≥3,600 instructions) and 10,630 small ones (<3,600 instructions). We compare with other fuzzers (i.e., sFuzz, ILF, and Con- Fuzzius). Particularly, we visualize the comparison results on small contracts in Fig. 6(a) and on large contracts in Fig. 6(b), respectively. We plot the tendency of branch coverage over time. It can be seen that IR-Fuzz consistently outperforms other fuzzers. Quantitatively, IR-Fuzz achieves 90.10% cover- age on small contracts, 28.20%, 20.10%, and 10.10% higher than sFuzz, ILF, and ConFuzzius, respectively. On large con- tracts, IR-Fuzz achieves 19.20%, 14.00%, and 9.10% higher IR-Fuzz Mythril ConFuzzius Oyente ILF Osirs sFuzz Securify Tool 0 50 100 150 200 250 300Time (s) 21.30 30.06 33.26 33.50 49.88 53.41 103.52 273.30 (a) Average execution time 20 40 60 80 100 120 Time (S) 0 5 10 15 20 25 30 35 40Test Cases (K) sFuzz IR-Fuzz (b) Number of generated test cases Fig. 7 Visual comparison of efﬁciency on different tools. coverage, respectively. Moreover, we also observe that IR-Fuzz reaches the highest coverage with less time required than other fuzzers. On average, IR-Fuzz spent only 10s to achieve the highest coverage (i.e., 90.10% on small contracts and 79.10% on large contracts), while the other three fuzzers spent 18s, 16s, 13s, respectively. We conjecture that the advantages of IR-Fuzz in achieving high branch coverage come from three aspects. First, IR-Fuzz generates the high-quality function invocation sequence by adopting a dependency-aware sequence generation strategy, enforcing the fuzzer to tap into richer states. Second, IR- Fuzz employs a branch distance-based measure to iteratively optimize the generated test cases, steering fuzzing towards covering new branches. Thirdly, IR-Fuzz takes into account the signiﬁcance of rare branches and branches that are likely to have vulnerabilities, and designs an energy allocation mech- anism to ﬂexibly guide fuzzing energy allocation towards these critical branches. Moreover, IR-Fuzz utilizes the feedback results generated by the energy allocation mechanism to guide seed mutation, which further increases branch coverage. D. Efﬁciency (RQ3) In this subsection, we systematically examine the efﬁciency of IR-Fuzz and compare it against other methods. First, we conduct experiments to measure the overhead of IR-Fuzz by calculating the average execution time on each contract. We run IR-Fuzz on the whole dataset, revealing that it spends 21.30s per contract on average. Fig. 7(a) compares IR- Fuzz to other methods in terms of the average execution time. From the ﬁgure, we observe that IR-Fuzz is signiﬁcantly more efﬁcient than others. Particularly, its average execution time is 251s and 82.22s faster than Securify and sFuzz, respectively. We believe the reasons for the much faster speed of IR-Fuzz are as follows. (1) IR-Fuzz can quickly infer the ordered function invocation sequence, accelerating fuzzing execution. (2) IR-Fuzz adopts the branch distance-based measure to boost its efﬁciency in generating test cases, which requires much fewer mutations to reach a target branch. (3) IR-Fuzz leverages the energy allocation mechanism to ﬂexibly assign fuzzing resources, saving overall fuzzing time. Next, we further measure the efﬁciency of IR-Fuzz by counting how many test cases are generated over time. Specif- ically, each contract is run for 120 seconds in the experiment. We show the average statistics in Fig. 7(b), where the x- axis represents how long a contract is fuzzed, and the y-axis denotes the number of test cases generated during fuzzing. IEEE TRANSACTIONS ON INFORMATION FORENSICS AND SECURITY 12 TABLE IV Accuracy and coverage comparison (%) be- tween IR-Fuzz and its variants. Method V ulnerability T ype (Accuracy) Co v erage TP BN DG FE UC RE OF SE IR-Fuzz-WSG 90.01 93.38 94.48 92.73 96.70 94.80 93.86 96.42 62.03 IR-Fuzz-WDM 89.94 93.56 93.31 92.15 96.26 94.51 92.02 94.12 69.89 IR-Fuzz-WEA 89.22 91.00 91.86 91.00 96.04 92.49 91.60 95.82 42.63 IR-Fuzz 90.05 93.79 95.06 94.48 98.03 98.73 98.73 99.73 85.65 From Fig. 7(b), we can learn that (1) IR-Fuzz signiﬁcantly generates more test cases than sFuzz within the same time interval. On average, IR-Fuzz generates approximately 350 test cases per second, 290 more than sFuzz; (2) The number of test cases generated by IR-Fuzz has increased rapidly over time while the process is slow in sFuzz. These evidences reveal that IR-Fuzz can efﬁciently generate test cases for fuzzing smart contracts. E. Ablation Study (RQ4) By default, IR-Fuzz adopts the proposed sequence gener- ation strategy to generate the function invocation sequence. It is interesting to see the effect of removing this strategy. Moreover, IR-Fuzz utilizes a branch distance-based measure to select and evolve test cases iteratively. We are curious about how much this method contributes to the performance of IR-Fuzz. Finally, IR-Fuzz introduces an energy allocation mechanism to ﬂexibly guide fuzzing resource allocation. It is useful to evaluate the contributions of this mechanism by removing it from IR-Fuzz as well. In what follows, we conduct experiments to study the three components, respectively. Study on Sequence Generation Strategy. We removed the sequence generation strategy (introduced in §IV-A) from IR-Fuzz and replaced it with a random sequence construction method. This variant is denoted as IR-Fuzz-WSG, where WSG is short for without sequence generation strategy. Quantitative results are summarized in Table IV. We can observe that the performance of IR-Fuzz is signiﬁcantly better than IR-Fuzz- WSG. For example, on the reentrancy detection task, IR-Fuzz achieves 3.97% and 23.62% improvement in terms of accuracy and branch coverage, respectively. Study on Branch Distance-based Seed Evolution Paradigm. To evaluate the effect of the branch distance- based seed evolution paradigm, we analyze the performance of IR-Fuzz with and without it, respectively. Towards this aim, we modify IR-Fuzz by removing this mechanism, utilizing random test case generation. This variant is denoted as IR- Fuzz-WDM, where WDM is short for without the distance measure mechanism. The empirical ﬁndings are demonstrated in Table IV, where we can observe that the accuracy and branch coverage of IR-Fuzz-WDM are lower than IR-Fuzz by an average of 2.03% and 15.76% on the eight types of vulnerabilities. This reveals that incorporating the branch distance-based measure is necessary and critical to improve the performance of IR-Fuzz. Study on Energy Allocation Mechanism. We further investigate the impact of the energy allocation mechanism in IR-Fuzz. Speciﬁcally, we remove this mechanism while replacing it with assigning fuzzing energy equally to every contract Gamble { uint256 private number; uint256 phase; address winner; constructor ( uint256 num ) { require (num < 100); number = num; phase = 0; } / * 0 : guess 1: start a new game * / function guess ( uint256 fee ) payable external { require (phase == 0 && fee == 10 finney ); if (address( this ).balance == number * 10 finney ) { / * Ether strict equality * / winner = msg.sender ; phase = 1; } } function newGame ( uint256 num ) external { require (phase == 1 && msg.sender == winner ); winner.transfer(address( this ). balance); require (num < 100); number = num; phase = 0; } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 Fig. 8 An example contract where IR-Fuzz detects a new kind of vulnerability, i.e., dangerous Ether strict equality. branch. This new variant is termed as IR-Fuzz-WEA, namely IR-Fuzz without an energy allocation mechanism. The com- parison results are presented in Table IV, where all eight types of vulnerabilities are involved. We can clearly see that the accuracy and branch coverage of IR-Fuzz-WEA are lower than IR-Fuzz by an average of 4.87% and 43.02%. This suggests that the energy allocation mechanism contributes to signiﬁcant performance gains in IR-Fuzz. F. Case Study We now present a case study on a new vulnerability (i.e., dangerous Ether strict equality). To our knowledge, existing investigated methods cannot expose this vulnerability yet. Fig. 8 shows a simpliﬁed example that implements a gambling game. A user can join the game by transferring participation fees with 10 ﬁnney. If a user is the number-th participant, he will become the winner of the game (line 14). The winner can obtain the whole balance of the contract by calling newGame() and starting a next round of the game. However, if the contract owner had pre-stored some Ethers in the contract, the balance of the contract will never be equal to the sum of users’ participation fees (namely, the branch condition at line 14 will never be satisﬁed). This indicates that there will be no winner in the game, and the participation fees in the contract will be permanently frozen. We empirically checked this contract using existing tools and manually inspected their generated reports. Unfortunately, the dangerous Ether strict equality vulnerability cannot yet be detected by these methods. In contrast, IR-Fuzz successfully identiﬁes this vulnerability. Speciﬁcally, T1: IR-Fuzz infers the function invocation sequence as: guess()→ newGame() and generates a test case to cover the requirement at line 13. IEEE TRANSACTIONS ON INFORMATION FORENSICS AND SECURITY 13 T2: Record the instruction BALANCE when the fuzzing process reaches line 14. T3: Check if BALANCE is followed by the jump or compare instructions. T4: IR-Fuzz ﬁnds that line 14 is reachable and the vulnerability-speciﬁc patterns of dangerous Ether strict equality are triggered, outputting that the contract has such a vulnerability. VI. DISCUSSION In this section, we discuss the limitations of IR-Fuzz and potential future improvements. Sequence Generation Analysis. IR-Fuzz generates the ordered function invocation sequence with the guidance of the order priority computation rules mentioned in §IV-A. We calculate the order priority of function calls in the sequence by analyzing the data ﬂow dependencies of global variables. In the case that several functions perform frequent write and read operations on global variables, the calculation of function order priority may bring a certain amount of computation overhead. Seed Mutation Optimization. IR-Fuzz refers to several seed mutation strategies adopted from AFL, usually using bit manipulation techniques, e.g., bit ﬂipping. However, such a method still bears the problem of generating repetitive and invalid test cases. Moreover, arbitrarily mutating bits of a test input may ignore certain critical parts of the input that should not be mutated, reducing the probability of hitting the branches guarded by strict conditions. Therefore, in the subsequent work, we may focus on enabling the fuzzer not to mutate these crucial parts of a test case, making the fuzzing trigger deep and complex states. VII. CONCLUSION In this paper, we present IR-Fuzz, a fully automatic fuzzing framework equipped with invocation ordering and crucial branch revisiting, to detect vulnerabilities in smart contracts. Speciﬁcally, we propose a sequence generation strategy con- sisting of invocation ordering and prolongation to generate the high-quality function invocation sequence, enforcing the fuzzer to trigger complex and deep states. Furthermore, we design a seed optimization paradigm that engages a branch distance-based measure to evolve test cases iteratively to- wards a target branch, alleviating the randomness of test case generation. Finally, we develop an energy allocation mechanism to ﬂexibly guide fuzzing resource allocation to- wards rare and vulnerable branches, improving the overall fuzzing efﬁciency and branch coverage. Experimental results demonstrate that IR-Fuzz signiﬁcantly surpasses state-of-the- art fuzzing approaches by a large margin. Our implementation and dataset are released to facilitate future research. The presented techniques in IR-Fuzz might also be transferable to fuzz other software programs. REFERENCES [1] Z. Zheng, S. Xie, H.-N. Dai, X. Chen, and H. Wang, “Blockchain challenges and opportunities: A survey,” International Journal of Web and Grid Services, vol. 14, no. 4, pp. 352–375, 2018. [2] Z. Liu, P. Qian, X. Wang, Y. Zhuang, L. Qiu, and X. Wang, “Com- bining graph neural networks with expert knowledge for smart contract vulnerability detection,” IEEE Transactions on Knowledge and Data Engineering, 2021. [3] P. Qian, Z. Liu, X. Wang, J. Chen, B. Wang, and R. Zimmermann, “Digital resource rights conﬁrmation and infringement tracking based on smart contracts,” in 2019 IEEE 6th International Conference on Cloud Computing and Intelligence Systems (CCIS). IEEE, 2019, pp. 62–67. [4] G. Wood et al., “Ethereum: A secure decentralised generalised trans- action ledger,” Ethereum project yellow paper, vol. 151, no. 2014, pp. 1–32, 2014. [5] Y.-P. Chen and J.-C. Ko, “Cryptoar wallet: A blockchain cryptocurrency wallet application that uses augmented reality for on-chain user data display,” in Proceedings of the 21st International Conference on Human- Computer Interaction with Mobile Devices and Services, 2019, pp. 1–5. [6] P. De Filippi, “Blockchain-based crowdfunding: what impact on artistic production and art consumption?” Observatório Itaú Cultural, no. 19, 2015. [7] G. Mirabelli and V. Solina, “Blockchain and agricultural supply chains traceability: research trends and future challenges,” Procedia Manufac- turing, vol. 42, pp. 414–421, 2020. [8] J. Kokina, R. Mancha, and D. Pachamanova, “Blockchain: Emergent industry adoption and implications for accounting,” Journal of Emerging Technologies in Accounting, vol. 14, no. 2, pp. 91–100, 2017. [9] M. Rodler, W. Li, G. O. Karame, and L. Davi, “Evmpatch: timely and automated patching of ethereum smart contracts,” in 30th {USENIX} Security Symposium ({USENIX} Security 21), 2021. [10] P. Qian, Z. Liu, Q. He, B. Huang, D. Tian, and X. Wang, “Smart contract vulnerability detection technique: A survey,” arXiv preprint arXiv:2209.05872, 2022. [11] S. S. Kushwaha, S. Joshi, D. Singh, M. Kaur, and H.-N. Lee, “Systematic review of security vulnerabilities in ethereum blockchain smart contract,” IEEE Access, 2022. [12] Inspex, “Reentrancy attack on cream ﬁnance,” Webiste, 2021, https://inspexco.medium.com/ reentrancy-attack-on-cream-ﬁnance-incident-analysis-1c629686b6f5. [13] S. Palladino, “The parity wallet hack ex- plained,” Webiste, 2017, https://blog.zeppelin.solutions/ on-the-parity-wallet-multisig-hack-405a8c12e8f7. [14] K. Bhargavan, A. Delignat-Lavaud, C. Fournet, A. Gollamudi, G. Gonthier, N. Kobeissi, N. Kulatova, A. Rastogi, T. Sibut-Pinote, N. Swamy et al., “Formal veriﬁcation of smart contracts: Short paper,” in Proceedings of the 2016 ACM Workshop on Programming Languages and Analysis for Security. ACM, 2016, pp. 91–96. [15] L. Luu, D.-H. Chu, H. Olickel, P. Saxena, and A. Hobor, “Making smart contracts smarter,” in Proceedings of the 2016 ACM SIGSAC conference on computer and communications security. ACM, 2016, pp. 254–269. [16] T. D. Nguyen, L. H. Pham, J. Sun, Y. Lin, and Q. T. Minh, “sfuzz: An efﬁcient adaptive fuzzer for solidity smart contracts,” in Proceedings of the ACM/IEEE 42nd International Conference on Software Engineering, 2020, pp. 778–788. [17] P. Zong, T. Lv, D. Wang, Z. Deng, R. Liang, and K. Chen, “Fuzzguard: Filtering out unreachable inputs in directed grey-box fuzzing through deep learning,” in 29th {USENIX} Security Symposium ({USENIX} Security 20), 2020, pp. 2255–2269. [18] Y. Li, S. Ji, C. Lyu, Y. Chen, J. Chen, Q. Gu, C. Wu, and R. Beyah, “V- fuzz: Vulnerability prediction-assisted evolutionary fuzzing for binary programs,” IEEE Transactions on Cybernetics, 2020. [19] V. Wüstholz and M. Christakis, “Targeted greybox fuzzing with static lookahead analysis,” in 2020 IEEE/ACM 42nd International Conference on Software Engineering (ICSE). IEEE, 2020, pp. 789–800. [20] B. Jiang, Y. Liu, and W. Chan, “Contractfuzzer: Fuzzing smart contracts for vulnerability detection,” in Proceedings of the 33rd ACM/IEEE International Conference on Automated Software Engineering. ACM, 2018, pp. 259–269. [21] V. Wüstholz and M. Christakis, “Harvey: A greybox fuzzer for smart contracts,” in Proceedings of the 28th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering, 2020, pp. 1398–1409. [22] J. He, M. Balunovi´c, N. Ambroladze, P. Tsankov, and M. Vechev, “Learning to fuzz from symbolic execution with application to smart contracts,” in Proceedings of the 2019 ACM SIGSAC Conference on Computer and Communications Security, 2019, pp. 531–548. [23] C. F. Torres, A. K. Iannillo, A. Gervais, and R. State, “Confuzzius: A data dependency-aware hybrid fuzzer for smart contracts,” in 2021 IEEE European Symposium on Security and Privacy (EuroS&P). IEEE, 2021, pp. 103–119. 14 [24] N. Atzei, M. Bartoletti, and T. Cimoli, “A survey of attacks on ethereum smart contracts (sok),” in International Conference on Principles of Security and Trust. Springer, 2017, pp. 164–186. [25] Y. Zhuang, Z. Liu, P. Qian, Q. Liu, X. Wang, and Q. He, “Smart contract vulnerability detection using graph neural network,” in IJCAI, 2020, pp. 3283–3290. [26] P. Qian, Z. Liu, Q. He, R. Zimmermann, and X. Wang, “Towards automated reentrancy detection for smart contracts based on sequential models,” IEEE Access, vol. 8, pp. 19 685–19 695, 2020. [27] Y. Hirai, “Deﬁning the ethereum virtual machine for interactive theorem provers,” in International Conference on Financial Cryptography and Data Security. Springer, 2017, pp. 520–535. [28] I. Grishchenko, M. Maffei, and C. Schneidewind, “A semantic frame- work for the security analysis of ethereum smart contracts,” in Interna- tional Conference on Principles of Security and Trust. Springer, 2018, pp. 243–269. [29] E. Hildenbrandt, M. Saxena, N. Rodrigues, X. Zhu, P. Daian, D. Guth, B. Moore, D. Park, Y. Zhang, A. Stefanescu et al., “Kevm: A complete formal semantics of the ethereum virtual machine,” in 2018 IEEE 31st Computer Security Foundations Symposium (CSF). IEEE, 2018, pp. 204–217. [30] J. Feist, G. Grieco, and A. Groce, “Slither: a static analysis framework for smart contracts,” in 2019 IEEE/ACM 2nd International Workshop on Emerging Trends in Software Engineering for Blockchain (WETSEB). IEEE, 2019, pp. 8–15. [31] P. Tsankov, A. Dan, D. Drachsler-Cohen, A. Gervais, F. Buenzli, and M. Vechev, “Securify: Practical security analysis of smart contracts,” in Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security. ACM, 2018, pp. 67–82. [32] C. Liu, H. Liu, Z. Cao, Z. Chen, B. Chen, and B. Roscoe, “Reguard: ﬁnding reentrancy bugs in smart contracts,” in Proceedings of the 40th International Conference on Software Engineering: Companion Proceeedings. ACM, 2018, pp. 65–68. [33] H. Liang, X. Pei, X. Jia, W. Shen, and J. Zhang, “Fuzzing: State of the art,” IEEE Transactions on Reliability, vol. 67, no. 3, pp. 1199–1218, 2018. [34] Y. Zheng, A. Davanian, H. Yin, C. Song, H. Zhu, and L. Sun, “Firm- aﬂ: high-throughput greybox fuzzing of iot ﬁrmware via augmented process emulation,” in 28th {USENIX} Security Symposium ({USENIX} Security 19), 2019, pp. 1099–1114. [35] M. Böhme, V.-T. Pham, M.-D. Nguyen, and A. Roychoudhury, “Directed greybox fuzzing,” in Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security, 2017, pp. 2329–2344. [36] W. Xu, H. Moon, S. Kashyap, P.-N. Tseng, and T. Kim, “Fuzzing ﬁle systems via two-dimensional input space exploration,” in 2019 IEEE Symposium on Security and Privacy (SP). IEEE, 2019, pp. 818–834. [37] P. Chen and H. Chen, “Angora: Efﬁcient fuzzing by principled search,” in 2018 IEEE Symposium on Security and Privacy (SP). IEEE, 2018, pp. 711–725. [38] S. Gan, C. Zhang, X. Qin, X. Tu, K. Li, Z. Pei, and Z. Chen, “Collaﬂ: Path sensitive fuzzing,” in 2018 IEEE Symposium on Security and Privacy (SP). IEEE, 2018, pp. 679–696. [39] “Technical “whitepaper” for aﬂ.” Website, http://lcamtuf.coredump.cx/ aﬂ/technical_details.txt. [40] M. Böhme, V.-T. Pham, and A. Roychoudhury, “Coverage-based grey- box fuzzing as markov chain,” IEEE Transactions on Software Engi- neering, vol. 45, no. 5, pp. 489–506, 2017. [41] H. Chen, Y. Xue, Y. Li, B. Chen, X. Xie, X. Wu, and Y. Liu, “Hawkeye: Towards a desired directed grey-box fuzzer,” in Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security, 2018, pp. 2095–2108. [42] J. Zhang, X. Wang, H. Zhang, H. Sun, K. Wang, and X. Liu, “A novel neural source code representation based on abstract syntax tree,” in 2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE). IEEE, 2019, pp. 783–794. [43] Y. Shin and L. Williams, “Can traditional fault prediction models be used for vulnerability prediction?” Empirical Software Engineering, vol. 18, no. 1, pp. 25–59, 2013. [44] Z. Liu, P. Qian, X. Wang, L. Zhu, Q. He, and S. Ji, “Smart contract vulnerability detection: From pure neural network to interpretable graph feature and expert pattern fusion,” in IJCAI, 2021, pp. 2751–2759. [45] C. F. Torres, J. Schütte, and R. State, “Osiris: Hunting for integer bugs in ethereum smart contracts,” in Proceedings of the 34th Annual Computer Security Applications Conference, 2018, pp. 664–676. [46] B. Mueller, “A framework for bug hunting on the ethereum blockchain,” Webiste, 2017, https://github.com/ConsenSys/mythril. [47] “Etherscan,” Website, https://etherscan.io/.","libVersion":"0.2.3","langs":""}