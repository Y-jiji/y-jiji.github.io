{"path":"_assets/icpc-cerc-2022-solution.pdf","text":"ICPC CERC 2022 Solution Presentation Ljubljana, 27. 11. 2022 Solution Presentation Ljubljana, 27. 11. 2022 L - The Game Simulate the described card game. ‚Ä¢ maintain lists of cards: ‚Äì rows, hand, deck ‚Ä¢ careful implementation ‚Äì prioritize backward moves ‚Äì choose best regular move ‚Ä¢ sort by (abs. difference, hand, row) hand: 16, 55, 70, 67, 13, 9, 12, 40 deck: 14, 90, 31, 33, ‚Ä¶ rows: 1, 3 1, 7, 8, 9 100, 60, 70 100 D - Deforestation Cut a tree into parts of size at most W using fewest cuts. ‚Ä¢ recursive input ‚Ä¢ greedy strategy ‚Ä¢ prune the tree from leaves towards the root ‚Äì cut off part of size W ‚Ä¢ node with ‚Äústumps‚Äù of sizes xi < W ‚Äì ‚àë xi > W --> cut off largest stumps ‚Äì ‚àë xi ‚â§ W --> cut up parent branch ‚Ä¢ solve(a) ‚Ä¶ optimal cutting of subtree rooted in a ‚Äì minimum number of cuts ‚Äì remaining size of the stump ‚Ä¢ O(n log n) ‚Äì challenge: O(n) x1 x2 x3 x4 x5 E - Denormalization Undo normalization of a list of small integers. ‚Ä¢ too many possible vector lengths ‚Ä¶ d = ‚àö(‚àë ai 2) ‚Ä¢ intermediate step: normalize to min=1 (divide by k=min(a)) ‚Ä¢ reverse direction ‚Äì norm -> min: divide by min(x) ‚Äì min -> a: ‚Ä¢ ai = mini ‚àô k, 1 ‚â§ k ‚â§ 10 000 ‚Ä¢ find integer k that yields ai that are closest to integer values and in range ‚Ä¢ O(AN) ‚Ä¢ making an assumption about the value of min(a) or max(a) a = 5 6 10 15 30 6 min = 1.000 1.196 1.993 2.993 5.978 1.196 x/norm = 0.138 0.165 0.275 0.413 0.825 0.165 C - Constellations Compute hierarchical clustering of points using squared Euclidean distance. ‚Ä¢ brute-force: O(n5) O(n3) ‚Ä¢ constellation ‚Ä¶ list of stars ‚Ä¢ priority queue of potential constellations ‚Äì (distance, min(a,b), max(a,b)) ‚Ä¢ merge, update distances ùëë‚Ä≤ ùê¥, ùêµ = œÉùëé œÉùëè ùëé ‚àí ùëè 2 ùëë‚Ä≤ ùê¥ + ùêµ, ùê∂ = ùëë‚Ä≤ ùê¥, ùê∂ + ùëë‚Ä≤ ùêµ, ùëê ‚Ä¢ O(n2 log n) ‚Äì form O(n) constellations ‚Äì update O(n) distances in O(log n) B A C D A+B G - Greedy Drawers Construct a counterexample for a greedy assignment of notebooks to drawers. ‚Ä¢ does a notebook fit into a drawer? ‚Äì horizontal orientation ‚Ä¢ possible counterexample: ‚Äì notebooks of dimensions (1,x), (2,x-1), ‚Ä¶, (x,x) ‚Äì a drawer can contain a range of notebooks ‚Äì 50% chance of suboptimal assignment ‚Äì repeat the pattern ‚Ä¢ prob. of success (greedy finds suboptimal solution): ‚Äì single case: p1 = 1 - 0.5(150/8) ‚Äì all 20 cases: p = p1 20 = 99.995% K - Skills in Pills Find an arrangement with a minimum number of pills that avoids taking two pills on the same day. ‚Ä¢ if we could take both pills on the same day ‚Äì take a pill as late as possible (pill A every k-th day and B every j-th) ‚Ä¢ resolve first ‚Äúcollision‚Äù ‚Äì shift one of the pills one day back; which one? ‚Ä¢ dynamic programming ‚Äì f(n, AB) ‚Ä¶ min number of pills taken in the remaining n days if we take pills A and B in this order in preceding two days ‚Äì compute next collision ‚Äì O(n) ‚Ä¢ challenge: sublinear greedy solution A B A AB A B A B A AB e.g. A=2, B=3, N=8 take A early take B early 6 pills 7 pills B - Combination Locks Find the winner in a two-player game with non-repeating states ‚Ä¢ Hypercube graph ‚Äì node = difference pattern, forbidden nodes ‚Äì can move to any adjacent node ‚Äì bipartite ‚Ä¢ alternatingly building a simple path in a graph ‚Ä¢ possible strategy: following edges in a maximum matching ‚Ä¢ maximum matching that doesn‚Äôt include the starting node? ‚Äì Yes: Bob can follow matched edges ‚Ä¢ stuck at unmatched node -> there would exist an augmenting path ‚Äì No: Alice can follow matched edges ‚Ä¢ stuck at unmatched node -> flip edges, get an unmatched start node F - Differences Find a string with Hamming distance K to all other strings. ‚Ä¢ O(n2) too slow ‚Ä¢ precompute sets of strings that have character c at position j ‚Ä¶ f(j,c) ‚Ä¢ sets of strings differing from string Sx at each position j (union) ‚Ä¢ Hamming distances from Sx ‚Ä¢ speed-up: ‚Äì use bit masks to represent sets of strings? ‚Äì use polynomial hashes ... O(nm) ‚Ä¢ e.g., f(0,A) = (p0+p2) % mod, g(j) = ‚àë f(j,A) ‚Ä¢ Sx ‚Ä¶ ‚àëj g(j) ‚Äì f(j, Sx,j) should be equal to ‚àëi Kpi - px j=0 A: {0,2} B: {1} C: {3,4,5} {0,1,2} j=1 A: {1,3,4} B: {0,2} C: {5} {0,2,5} Sx=CA, S={AB, BA, AB, CA, CA, CC} d = [2, 1, 2, 0, 0, 1] goal: [K, K, K, 0, K, K] I - Money Laundering Compute individual‚Äôs ownership shares in a network of company ownerships. ‚Ä¢ simulate redistribution ‚Äì x = [x1, ‚Ä¶, xn]T ‚Ä¶ vector of company incomes ‚Äì redistribution matrix A, x‚Äô = Ax ‚Äì Ai,j ‚Ä¶ share received by i from j ‚Äì Ak converges to 0 ‚Ä¢ accumulate output values ‚Äì o = x + Ax + A2x + ‚Ä¶ a) geometric series ‚Ä¢ o = (I - A)-1 x ‚Ä¢ inverse (Gauss‚ÄìJordan elimination) b) power method ‚Ä¢ y = [x1, ‚Ä¶, xn, o1, ‚Ä¶, on]T, B= ùê¥ 0 ùêº ùêº ‚Ä¢ y‚Äô = By, Bbig ‚Ä¶ exponentiation by squaring oi P1 P2 Ci Cj Ai,j xi xj I - Money Laundering ‚Ä¢ industrial sectors = strongly connected components ‚Äì Tarjan, Kosaraju, ‚Ä¶ ‚Äì small! ‚Äì ownership structure (income) from preceding companies ‚Ä¢ matrix X: Xi,j ‚Ä¶ income received by company i from company j ‚Äì extract submatrix of X relevant to the SCC (dim. S x C) ‚Äì propagate income within SCC ‚Äì distribute to persons and companies ‚Ä¢ O(C/S S3 + K C) ‚Äì C ‚Ä¶ companies ‚Äì K ‚Ä¶ edges ‚Äì S ‚Ä¶ max size of SCC J - Mortgage Given the monthly incomes, compute the largest monthly payment that you can afford in the range of months [L ‚Ä¶ R]. a) algebraic approach ‚Ä¢ consider a fixed payment x ‚Äì bj = balance on day j ‚Äì range minimum query (tree) ‚Ä¢ unknown x? ‚Äì sj(x) is a linear function of x ‚Äì store lower envelopes s‚Äô(x) of sj(x) in each node ‚Äì binary search for x in each range: s(x) ‚â• sL-1(x) ‚Ä¢ sL-1 is the flattest ‚Äì O(n log n + m log2 n) sL-1(x) s‚Äô(x) J - Mortgage b) geometric approach ‚Äì points (i, ci), ci = ‚àëj=1..i ai ‚Äì query [L, R] ‚Ä¶ steepest line originating from L-1 ‚Ä¢ partition points into groups ‚Äì lower hull ‚Äì tree structure of groups ‚Ä¢ O(n) groups overall ‚Ä¢ O(log n) groups cover every query range ‚Ä¢ binary search in a group ‚Äì max prefix of the hull with segments that are clockwise to the line from L-1 ‚Ä¢ careful with overflows ‚Ä¢ O(n log n + m log2 n) L R L A - Bandits Protect nodes in a tree at a distance at most r from X and answer queries about the level of protection of road Y. ‚Ä¢ centroid decomposition ‚Ä¢ new security contract at X with radius r ‚Äì mark parts of the tree as protected ‚Ä¶ O(log2 n) ‚Äì store affected distance in a tree structure X A B C r r-d(X,A) *excluding subtree of X r-d(X,B) r-d(X,C) A - Bandits ‚Ä¢ coverage of edge U-V with length l ‚Äì V ‚Ä¶ more important centroid ‚Äì protection originating from subcomponents of V (U, X, A), entering via U ‚Ä¢ # of markings ‚â• l + d(U,A) [excluding subtree of X] ‚Äì protection from large components (e.g. C) containing U and V ‚Ä¢ # of markings ‚â• l + min(d(U,C), d(V,C)) [excluding subtree of B] ‚Ä¢ O(Q log2 N) V U A B C X U V ‚â• l + d(U,A) *excluding subtree of X X A D H - Insertions Insert string T into S to maximize the number of patterns P. ‚Ä¢ consider all insertions after k chars ‚Ä¢ count P in S and T, subtract those broken by insertion ‚Äì KMP ‚Ä¶ locations of P in S and T a) small patterns |P|‚â§|T| ‚Äì p = len. of longest prefix of P as a suffix of S[:k] (KMP search phase) ‚Ä¢ is there an appropriate suffix of P (of length x=|P|-p) in T? ‚Äì len. of longest suffix of P ending in T[L] (z-algorithm) equal to L? ‚Ä¢ precompute matches for shorter prefixes (KMP fail. fun.) ‚Äì O(|S| + |T| + |P|) TS[:k] S[k:]p x H - Insertions b) large patterns |P| > |T| ‚Äì can expand across entire T ‚Ä¢ does T match with shifted P? KMP search for T in P ‚Äì how many prefixes of P at the end of S[:k] match with suffixes of P at the start of S[k:]? ‚Ä¢ consider all pairs of shorter prefixes and suffixes ‚Ä¶ O(|S|‚àô|P|2) ‚Ä¢ consider only shorter prefixes ‚Ä¶ O(|S|‚àô|P|) ‚Äì as in the case for small patterns (z-algorithm) TS[:k] S[k:] i j H - Insertions ‚Ä¢ trees of KMP failure functions f(i) of P and g(j) PR ‚Äì x(i,j) = number of matching nodes (correct sum of length) on paths from i and j to the root ‚Äì x(i,j) = x(i,g(j)) + matchj(i) = x(f(i),j) + matchi(j) ‚Äì precomputation ‚Ä¶ O(|P|1.5) ‚Ä¢ x(i, 0) ‚Ä¢ x(i‚Äô, j) for well-positioned special nodes i‚Äô (including root) ‚Äì subtrees of size sqrt(n) ‚Ä¢ x(i,j) ‚Ä¶ move towards root to first special node (‚â§ sqrt(n)) ‚Ä¢ O(|S|+|T|+|P|1.5) i j The End","libVersion":"0.2.3","langs":""}