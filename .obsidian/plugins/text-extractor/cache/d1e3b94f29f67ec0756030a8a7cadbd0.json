{"path":"_assets/buchsbaum2004.pdf","text":"OPT VERSUS LOAD IN DYNAMIC STORAGE ALLOCATION∗ ADAM L. BUCHSBAUM† , HOWARD KARLOFF† , CLAIRE KENYON‡ , NICK REINGOLD† , AND MIKKEL THORUP† SIAM J. COMPUT. c⃝ 2004 Society for Industrial and Applied Mathematics Vol. 33, No. 3, pp. 632–646 Abstract. Dynamic storage allocation is the problem of packing given axis-aligned rectangles into a horizontal strip of minimum height by sliding the rectangles vertically but not horizontally. Where L = LOAD is the maximum sum of heights of rectangles that intersect any vertical line and OPT is the minimum height of the enclosing strip, it is obvious that OPT ≥ LOAD; previous work showed that OPT ≤ 3 · LOAD. We continue the study of the relationship between OPT and LOAD, proving that OPT = L + O((hmax/L)1/7)L, where hmax is the maximum job height. Conversely, we prove that for any ϵ> 0, there exists a c> 0 such that for all suﬃciently large integers hmax, there is a dynamic storage allocation instance with maximum job height hmax, maximum load at most L, and OPT ≥ L + c(hmax/L)1/2+ϵL, for inﬁnitely many integers L. En route, we construct several new polynomial-time approximation algorithms for dynamic storage allocation, including a (2 + ϵ)-approximation algorithm for the general case and polynomial-time approximation schemes for several natural special cases. Key words. approximation algorithms, dynamic storage allocation, polynomial-time approxi- mation schemes AMS subject classiﬁcations. 68Q17, 68Q25, 68W25, 68W40 DOI. 10.1137/S0097539703423941 1. Introduction. We study a simple rectangle-packing problem: Given a set of n isothetic (i.e., axis-parallel) open rectangles in the x-y plane, the ith extending from x-coordinate xi to x-coordinate yi on the real line and having height hi, slide each rectangle up or down but not sideways so that (1) each rectangle is a subset of the positive quadrant, (2) the regions of the plane they occupy are pairwise disjoint, and (3) the supremum of the y-coordinates used is minimized. Resembling oﬀ-line Tetris in which the rectangles slide vertically but not horizontally, this problem is formally known as dynamic storage allocation for the following reason. View a rect- angle starting at x-coordinate xi, ending at x-coordinate yi, and of height hi as a request for hi contiguous bytes of storage starting at time xi and ending at time yi. Then the problem of ﬁnding a rectangle placement that minimizes the supremum of the y-coordinates used is exactly that of minimizing the number of contiguous bytes needed to satisfy all memory requests. Formally, an instance of dynamic storage allocation is a set of some number n of jobs, each job i being an open interval Ii =(xi,yi) (for rationals xi <yi), which we assume without loss of generality is a subset of (0, 1), and a positive rational height hi. We say job i is live at x-coordinate t (or simply live at t)if t ∈ Ii. A feasible solution is an assignment of a nonnegative real s(i) to each job i such that if we deﬁne S(i) to be the open real interval (s(i),s(i)+ hi) (the region of memory assigned to job i during time period (xi,yi)), then for all t ∈ (0, 1), the jobs i that are live at t have pairwise disjoint S(i)’s. The goal is to minimize the makespan: maxi{s(i)+ hi}. ∗Received by the editors March 11, 2003; accepted for publication (in revised form) September 10, 2003; published electronically March 30, 2004. An extended abstract appears in Proceedings of the 35th ACM Symposium on Theory of Computing, 2003. http://www.siam.org/journals/sicomp/33-3/42394.html †AT&T Labs, Shannon Laboratory, 180 Park Ave., Florham Park, NJ 07932 (alb@research.att. com, howard@research.att.com, reingold@research.att.com, mthorup@research.att.com). ‡Laboratoire d’Informatique, Ecole Polytechnique, 91128 Palaiseau Cedex, France (kenyon@lix. polytechnique.fr). 632Downloaded 12/27/12 to 129.173.72.87. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php OPT VERSUS LOAD IN DYNAMIC STORAGE ALLOCATION 633 0 1 2 3 4 5 012345 G A C B D F E H Fig. 1.1. An optimal packing for the jobs (in the form (xi,yi,hi)) A =(0, 1, 3), B =(0, 3, 1), C =(1, 2, 2), D =(1, 4, 1), E =(2, 3, 1), F =(2, 5, 1), G =(3, 4, 2), and H =(4, 5, 3). The shaded region is a gap. In this example, LOAD =4, but OPT =5. By scaling, we will assume that each hi is integral, in which case it is easy to see that without loss of generality s(i) is integral too. Dynamic storage allocation was proven NP-complete in 1976 by Stockmeyer. (See problem SR2 in Garey and Johnson [3].) The ﬁrst polynomial-time, constant- factor approximation algorithm was given by Kierstead in 1988 [6], using a reduction from dynamic storage allocation to on-line coloring of interval graphs discovered by Woodall in 1973 [8] and independently by Chrobak and Slusarek in 1988 [1]. Kier- stead’s algorithm is an 80-approximation algorithm. Kierstead [7] later exhibited a 6-approximation algorithm for dynamic storage allocation. The next improvements were 5- and 3-approximation algorithms by Gergov [4, 5]. Neither of Gergov’s two algorithms uses the Woodall–Chrobak–Slusarek reduction. Deﬁne OPT to be the optimal makespan for a given instance. The load L(t) at (x-coordinate) t is the sum of hi over all jobs i that are live at t. The maximum load LOAD (also L) is the maximum over all t of the load at t. LOAD is a trivial lower bound on OPT. When all heights are equal, OPT = LOAD, and an optimal solution can be found via interval graph coloring. In general, however, OPT need not equal LOAD, as exempliﬁed by Figure 1.1. All four of the algorithms mentioned above actually ﬁnd packings of makespan at most c times LOAD, not just c times OPT, for the respective c (80, 6, 5, or 3). We further study the relationship between OPT and LOAD in dynamic storage allocation, providing new upper and lower bounds on the gap between them; all of our upper bounds are expressed algorithmically. Recall L = LOAD; denote the maximum job height by hmax and the minimum job height by hmin. Our main results are as follows. 1. We devise an algorithm that yields makespan (1 + O((hmax/L) 1/7))L. This bound is L + o(L) when hmax = o(L). When hmax is bounded by a constant, we improve the makespan bound to (1 + O(((lg2 L)/L) 1/4))L. Note that the case hmax = o(L) does not subsume that of hmax’s being a constant, because, e.g., L might itself be bounded by a constant. No result of the form OPT ≤ L + o(L) is possible in the general case, since one can “scale up” the heights in the example of Figure 1.1 to get L =4k and OPT =5k for any positive integer k. 2. For any ϵ> 0, there exists a c> 0 such that for all suﬃciently large constants hmax, there is a dynamic storage allocation instance with maximum job height hmax, maximum load at most L, and OPT ≥ (1 + c(hmax/L) 1/2+ϵ)L, for inﬁnitely many integers L. This is the ﬁrst nontrivial lower bound to include the case when hmax is bounded by a constant. This lower bound shows that our upper bounds in (1) areDownloaded 12/27/12 to 129.173.72.87. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php 634 BUCHSBAUM, KARLOFF, KENYON, REINGOLD, AND THORUP optimal up to the exact powers of hmax/L. In particular, the “1/7” in the general upper bound (and the “1/4” in the bounded-hmax upper bound) cannot be replaced by any real greater than 1/2. We also contribute the following corollaries to our main results. 1. For all ϵ> 0, we give polynomial-time, (2 + ϵ)-approximation algorithms. 2. We give polynomial-time approximation schemes (PTASs) for the following cases: (a) hmax = o(L); (b) hmax is bounded by a constant. Finally, using straightforward dynamic programming, we give a PTAS when hmin = Ω(L lg lg n/ lg n) and a polynomial-time, exact solution when L = O(lg n/ lg lg n). We begin in section 2 by introducing our main tool: boxing jobs into larger rectangles so that the total wasted space in the rectangles remains small. Along with some results for simple cases (small load and large jobs) described in section 3, we use boxing to devise our algorithms for bounded-height jobs (section 4) and ﬁnally for the remaining cases (section 5). We present the lower bound in section 6. 2. Boxing jobs. Let Y be any set of jobs and t be any x-coordinate. LY (t) denotes the load of the jobs in Y that are live at t. To box a set Y of jobs means to place the jobs into a box b of minimum x- coordinate xb = min{xj : j ∈ Y }, maximum x-coordinate yb = max{yj : j ∈ Y }, and height hb ≥ ∑ j∈Y hj.A boxing of a set Y into a set B of boxes is a partition of Y into at most |B| subsets, each of which is then boxed into a distinct box b ∈ B. The boxes can be viewed as jobs in a modiﬁed instance. Then LB (resp., LB(t)) is well deﬁned to mean the load of the boxes (resp., at t). In particular, any unused space in a box still counts toward the load contributed by that box. All of the boxing procedures that follow run in polynomial time. 2.1. Boxing for a ﬁxed time. Lemma 2.1. Given a set Y of unit-height jobs, all live at some ﬁxed x-coordinate t, an integer box-height parameter H, and a suﬃciently small positive ϵ, there exist a subset Y ′ of Y , |Y − Y ′|≤ 2H⌈1/ϵ 2⌉, a set B of boxes, each of height H, and a boxing of Y ′ into B such that at any x-coordinate u, LB(u) ≤ LY ′ (u)+4ϵLY (u). Proof. It is convenient to view a job starting at x and ending at y as a point (x, y) in the plane, as depicted in Figure 2.1(a)–(b). Now partition the jobs of Y into strips, as exempliﬁed by Figure 2.1(c). The ﬁrst two strips are deﬁned as follows. 1. Create a vertical strip consisting of the H⌈1/ϵ 2⌉ jobs with the earliest starting x-coordinates (or fewer if there are not enough jobs). 2. If any jobs remain, create a horizontal strip consisting of the H⌈1/ϵ 2⌉ jobs that remain with the latest ending x-coordinates (or fewer if not enough jobs remain). Deﬁne Y ′ to be the set of all jobs in neither the ﬁrst vertical nor the ﬁrst horizontal strip. Obviously |Y − Y ′|≤ 2H⌈1/ϵ 2⌉. Now partition the jobs of Y ′ into strips by repeating the following as long as jobs remain. 1. Create a vertical strip consisting of the H⌈1/ϵ⌉ jobs that remain with the earliest starting x-coordinates (or fewer if not enough jobs remain). 2. If any jobs remain, create a horizontal strip consisting of the H⌈1/ϵ⌉ jobs that remain with the latest ending x-coordinates (or fewer if not enough jobs remain). Now for every vertical strip of Y ′, take the jobs in order of decreasing ending x-coordinate in groups of size H (the last group of the last strip possibly smaller),Downloaded 12/27/12 to 129.173.72.87. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php OPT VERSUS LOAD IN DYNAMIC STORAGE ALLOCATION 635 A B C D B A C D x=y=t .125 .25 .375 .5 .625 .75 .875 10 .125 .25 .375 .5 .625 .75 .875 10.125.25.375.5.625.75.87510 (a) (b) (c) x=u Fig. 2.1. (a) Four jobs. (b) The jobs of (a) viewed as (x, y) points. Note that all jobs are above the x = y diagonal. (c) Stripping a set of jobs with H =2 and ϵ = .5. The rectangle Rt deﬁnes the set Y of jobs. The ﬁrst (leftmost) vertical and (topmost) horizontal strips each contains H⌈1/ϵ2⌉ =8 jobs. The remaining jobs, which comprise Y ′, are shown in the bold subrectangle. Y ′ is partitioned into strips containing H⌈1/ϵ⌉ =4 jobs each. Within each strip of 4 jobs in Y ′, the jobs are grouped (dotted lines) into groups of height H =2. The groups that intersect the line x = u are shaded. and box them. Similarly, for every horizontal strip of Y ′, take the jobs in order of increasing starting x-coordinate in groups of size H (the last group of the last strip possibly smaller), and box them. We analyze the construction using Figure 2.1(c). For all reals u, the jobs live at u correspond to the rectangle Ru = {(x, y): x<u<y}. The fact that the jobs in Y are all live at t means that all the corresponding vertices are inside the rectangle Rt. A box (other than a last box) corresponds to a group of exactly H jobs. If all are live at u, then these jobs contribute exactly H to LY ′ (u), because each job has unit height, and the box contributes exactly H to LB(u). If none of them is live at u, then they contribute 0 to LY ′ (u), and the box contributes 0 to LB(u). The troublesome case is the one in which some but not all of the jobs are live at u, since the jobs may contribute as little as 1 to LY ′ (u), while the box still contributes H to LB(u). Assume without loss of generality that u<t. Then the troublesome case cor- responds to groups of jobs whose vertices are on both sides of the line x = u.By construction, this can happen to at most one group in each horizontal strip of Y ′. (Re- call that points in a horizontal strip are grouped in order of increasing x-coordinates.) Moreover, this can happen to groups inside at most one vertical strip of Y ′. Notice that if the line x = u intersects, say, k horizontal strips of Y ′, then the rectangle Ru entirely contains at least k − 1 vertical strips of Y ′. (In fact, in the current case, Ru entirely contains at least k vertical strips of Y ′. In the symmetric case, when t<u, the number is k − 1. We argue without loss of generality.) If the rectangle Ru does not contain any job of Y ′, then the lemma trivially holds. Otherwise, Ru must contain all the jobs in the (only) vertical strip of Y − Y ′, which number H⌈1/ϵ 2⌉. Observe that LB(u) − LY ′ (u) ≤ kH + H⌈1/ϵ⌉ + H,(2.1) where the ﬁrst term accounts for the groups in the k horizontal strips that are inter- sected by x = u, the second term accounts for the groups in the single vertical stripDownloaded 12/27/12 to 129.173.72.87. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php 636 BUCHSBAUM, KARLOFF, KENYON, REINGOLD, AND THORUP that is intersected by x = u, and the third term accounts for (possibly) the last group of the last strip. But LY (u) ≥ H⌈1/ϵ 2⌉ + max{k − 1, 0}· H⌈1/ϵ⌉,(2.2) where the ﬁrst term accounts for the vertical strip of Y − Y ′, and the second accounts for the max{k − 1, 0} vertical strips of Y ′ that are contained in the rectangle Ru. Now observe that kH + H⌈1/ϵ⌉ + H ≤ (k − 1)H + H/ϵ +3H;(2.3) H/ϵ +3H ≤ Hϵ(3/ϵ +1/ϵ2) ≤ Hϵ(4/ϵ 2) ≤ (4ϵ)[H⌈1/ϵ 2⌉];(2.4) (k − 1)H ≤ ϵ max{k − 1, 0}· H⌈1/ϵ⌉≤ (4ϵ)[max{k − 1, 0}· H⌈1/ϵ⌉].(2.5) Combining equations (2.1)–(2.5) yields LB(u) − LY ′ (u) ≤ 4ϵLY (u). We call the jobs in Y − Y ′ unresolved jobs. 2.2. Boxing over all times. We bootstrap Lemma 2.1 so that we can box all the jobs (i.e., not just jobs live at a particular, ﬁxed x-coordinate) with just a small amount of wasted space. Our main technical result is particularly interesting when L ≫ (H lg H)lg(1/ϵ)/ϵ2. We use this theorem in the following sections to devise approximation schemes for dynamic storage allocation. Theorem 2.2. Given a set Z of jobs, each of height 1, an integer box-height parameter H, and a suﬃciently small positive ϵ, there exist a set B of boxes, each of height H, and a boxing of Z into B such that for all x-coordinates t, LB(t) ≤ (1+4ϵ)LZ(t)+ O ( H lg H ϵ2 lg 1 ϵ ) . To prove Theorem 2.2, we are going to apply Lemma 2.1 many times, boxing the unresolved jobs into additional boxes as we go along. Our general goal is to keep the wasted load (free space) in those additional boxes small at any x-coordinate. We use the following recursive method. Given are 1. a set X of jobs and an open bounding interval I, such that ∀j ∈ X, Ij ⊆ I; 2. a nonempty ﬁnite set of critical x-coordinates T = {inf I = t0 <t1 < ··· < tq <tq+1 = sup I}⊆ I ∪{inf I, sup I}; 3. a set F of free spaces. Each free space is an open subinterval of I of height 1 having endpoints in T . Any free space f ∈ F is called spanning if f = I and nonspanning otherwise. Initially, X = Z, I =(0, 1), T = {0,t, 1} for some arbitrary x-coordinate t at which some job from Z is live, and F = ∅. Recall that Ij =(xj,yj) denotes the interval of job j. With the help of T , deﬁne partition X =(R1 ∪ R2 ∪ ··· ∪ Rq) ∪ (X0 ∪ X1 ∪ ··· ∪ Xq) as follows. (See Figure 2.2.) First, deﬁne Xi = {j ∈ X : Ij ⊆ (ti,ti+1)} for 0 ≤ i ≤ q. The Xi’s contain precisely the jobs that are not live at any critical time. Then deﬁne the Ri’s recursively as in an interval tree [2]. Deﬁne X ′ = X \\ (X0 ∪ X1 ∪ ··· ∪ Xq), the set of jobs that are live at some (not necessarily unique) criticalDownloaded 12/27/12 to 129.173.72.87. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php OPT VERSUS LOAD IN DYNAMIC STORAGE ALLOCATION 637 R3 t1 t2 t3 t4 X1 X3 X0 X2 R2 R1 t0 Fig. 2.2. A set of jobs (solid rectangles) partitioned into subsets (dashed rectangles) Xi and Rj using critical x-coordinates t0,... ,t4. time. Note that q ≥ 1. Deﬁne R⌈q/2⌉ = {j ∈ X ′ : t⌈q/2⌉ ∈ Ij}. Deﬁne P to be the set of remaining jobs j of X ′ with yj <t⌈q/2⌉, and deﬁne Q to be the set of remaining jobs j of X ′ with t⌈q/2⌉ <xj. That is, R⌈q/2⌉ is the set of jobs that are live at t⌈q/2⌉; P is the set of jobs that are live at some critical time but end before t⌈q/2⌉; and Q is the set of jobs that are live at some critical time but start after t⌈q/2⌉.If P ̸= ∅, recursively partition P using {t1,t2,... ,t⌈q/2⌉−1}. Afterward, if Q ̸= ∅, recursively partition Q using {t⌈q/2⌉+1,t⌈q/2⌉+2,... ,tq}. We will box the jobs in the Ri’s, in the process establishing parallel, recursive instances of the decomposition to handle the Xi’s. First, to each Xi associate a set Fi of intervals (free spaces), initially empty. As sections of free spaces in F are used to box jobs in the Ri’s, the unused fragments will be deposited into the appropriate Fi’s for use deeper in the recursion, to box jobs in the Xi’s. To box the jobs in the Ri’s, ﬁrst apply Lemma 2.1 to each Ri,1 ≤ i ≤ q,inany order; note that all jobs in Ri are live at ti. For each i, this boxes all the jobs of Ri except for at most 2H⌈1/ϵ 2⌉ unresolved jobs. Now consider the set U of all the unresolved jobs from all the Ri’s. Derive an optimal packing of U using interval graph coloring. (Recall that all jobs are of height one.) This packing has makespan LU . Let s(F ) denote the subset of spanning free spaces of F .If |s(F )| <LU , create ⌈(LU −|s(F )|)/H⌉ boxes of height H and horizontal extent I. This yields H⌈(LU − |s(F )|)/H⌉ new spanning free spaces; add them to F . Now there are at least as many spanning free spaces in F as rows of the packing of U . For each 1 ≤ j ≤ LU , remove one spanning free space from F , and use it to place all the jobs in row j of the packing. This creates gaps, or unused portions, in the original free space, each of the form [α, β], where for some i, j: ti ≤ α<ti+1 and tj ≤ β< tj+1; recall that t0 = inf I and tq+1 = sup I. For each such [α, β], if i ̸= j, then split [α, β]into(α, ti+1), (ti+1,ti+2),... , (tj−1,tj), (tj,β); and add (α, ti+1)to Fi,(ti+1,ti+2)to Fi+1, ... ,(tj−1,tj)to Fj−1, and (tj,β)to Fj. Otherwise (i = j), simply deposit (α, β)into Fi. This fragments the gaps. Now all the jobs in all the Ri’s are boxed. Consider the unused free spaces in F , if any. Each is of the form (ti,tj) for some i ̸= j. Split each such (ti,tj)into (ti,ti+1), (ti+1,ti+2),... , (tj−1,tj). Add (ti,ti+1)to Fi,(ti+1,ti+2)to Fi+1, ... , and (tj−1,tj)to Fj−1. This passes down the unused free spaces to the subproblems. In parallel for each ℓ =0, 1, 2,... ,q,if Xℓ ̸= ∅, recursively apply the constructionDownloaded 12/27/12 to 129.173.72.87. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php 638 BUCHSBAUM, KARLOFF, KENYON, REINGOLD, AND THORUP with new X ← Xℓ, new free space set F ← Fℓ, new bounding interval I ← (tℓ,tℓ+1), and new critical x-coordinate set T ←{endpoints of elements of Fℓ}∪{tℓ,tℓ+1}. Note that this preserves the invariant that the endpoints of intervals in F are in T for each recursive subproblem. Also note that the unused free spaces passed down span their entire respective boundary intervals, whereas the gaps that were fragmented need not do so. This completes the construction. 2.3. Analysis. Fix a real u. (Recall that to prove Theorem 2.2 we want to bound the load of the boxes at any x-coordinate u in terms of the load of the original jobs at u.) For any m, deﬁne Im(u) to be the bounding interval of the depth-m recursive call whose bounding interval contains x-coordinate u. Similarly, deﬁne Tm(u)tobethe set of critical x-coordinates, pm(u)= |Tm(u)|, and Um(u) to be the set of unresolved jobs from all the Ri’s in that same depth-m recursive call. Deﬁne Fm(u) to be the set of free spaces during the same depth-m recursive call, and note that this set changes during that procedure. Figure 2.2, for example, depicts for some m a piece of the depth-m stage of the recursion; i.e., Im(u)=(t0,t4) for u ∈ (t0,t4). The jobs in each Xi will form the set of jobs for each subproblem at depth m+1; i.e., Im+1(u)=(t0,t1) for u ∈ (t0,t1), Im+1(u)=(t1,t2) for u ∈ (t1,t2), etc. Lemma 2.3. For all m, pm+1(u) ≤ 2H⌈1/ϵ 2⌉⌈lg(pm(u)+1)⌉ +2. Proof. Note that p0(u) = 3. In the depth-m recursive call, the deﬁnition of the Ri’s implies that the number of Ri’s containing jobs with endpoints in Im+1(u)is at most ⌈lg(pm(u)+1)⌉. (The process of repeatedly looking at the middle index resembles binary search, and the worst-case running time of binary search on a list of length p is ⌈lg(p +1)⌉.) For each such Ri, Lemma 2.1 is applied, and each application yields at most 2H⌈1/ϵ 2⌉ unresolved jobs. Each unresolved job contributes at most one new endpoint and hence at most one critical x-coordinate to each of two diﬀerent intervals Im+1(·). The total number of critical x-coordinates contributed to Im+1(u) is thus at most 2H⌈1/ϵ 2⌉⌈lg(pm(u)+1)⌉+2, where the “+2” comes from the endpoints inf Im+1(u) and sup Im+1(u). Corollary 2.4. For all m, pm(u)= O( H lg H ϵ2 lg 1 ϵ ). Proof sketch.If am+1 ≤ k lg am for all m, and a0 ≤ 3k lg k, then am ≤ 3k lg k for all m, a fact that is easily proven by induction on m. Let P denote the upper bound of the corollary. For all m, the number of critical x-coordinates in the subproblem deﬁned by bounding interval Im(u) is at most P . Let fm(u) denote the number of free spaces in Fm(u) at the beginning of that recursive call, and let f ′ m(u) denote the number of free spaces in Fm(u) at the end of that recursive call. Abusing notation, let Lm(u) denote the load of Um(u), the set of unresolved jobs from all the Ri’s in the depth-m recursive call over bounding interval Im(u). Lemma 2.5. For all m, Lm(u) ≤ 2H⌈1/ϵ 2⌉⌈lg(P +1)⌉. Proof. As above, at most ⌈lg(P +1)⌉ Ri’s include jobs that contain u′ for any u′ ∈ Im(u). By Lemma 2.1 each such Ri contributes at most 2H⌈1/ϵ 2⌉ unresolved jobs to Um(u). Corollary 2.6. For all m, f ′ m(u) ≤ fm(u)+2H⌈1/ϵ 2⌉⌈lg(P +1)⌉. Proof. Boxing the unresolved jobs in the depth-m recursive call requires creating at most ⌈Lm(u)/H⌉ new boxes of height H, which adds at most H⌈Lm(u)/H⌉ new (spanning) free spaces to Fm(u), after which free spaces are only removed from Fm(u). Lemma 2.5 completes the proof. Lemma 2.7. For all m, 1. fm+1(u) ≤ fm(u)+2H⌈1/ϵ 2⌉⌈lg(P +1)⌉; 2. if fm(u) ≥ 4H⌈1/ϵ 2⌉⌈lg(P +1)⌉, then fm+1(u) ≤ fm(u).Downloaded 12/27/12 to 129.173.72.87. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php OPT VERSUS LOAD IN DYNAMIC STORAGE ALLOCATION 639 Proof. 1. This follows from Corollary 2.6 and the fact that the fragmented gaps from any used spanning free space of Fm(u) are distributed to distinct subproblems. 2. The free spaces of Fm(u) at the beginning of the depth-m recursive call come from two sources. (i) Unused free spaces of Fm−1(u) that were passed down; as noted above, they yield spanning free spaces of Fm(u), i.e., free spaces that span the entire interval Im(u). (ii) Fragmented free spaces obtained during the depth-(m − 1) recursive call by placing an unresolved job in a free space of Fm−1(u). Lemma 2.5 implies that there are at most 2H⌈1/ϵ 2⌉⌈lg(P +1)⌉ such spaces. Assume fm(u) ≥ 4H⌈1/ϵ 2⌉⌈lg(P +1)⌉. The number of spanning free spaces is the total number of free spaces minus the number of nonspanning free spaces. Because there are at most 2H⌈1/ϵ 2⌉⌈lg(P +1)⌉ nonspanning free spaces, Fm(u) starts with at least 4H⌈1/ϵ 2⌉⌈lg(P +1)⌉− 2H⌈1/ϵ 2⌉⌈lg(P +1)⌉ =2H⌈1/ϵ 2⌉⌈lg(P +1)⌉ spanning free spaces. When the unresolved jobs are boxed during the depth-m recur- sive call, there are enough spanning free spaces to ﬁt all the unresolved jobs (again by Lemma 2.5), so no new free spaces are created. Thus, fm+1(u) ≤ fm(u). Corollary 2.8. For all m, fm(u)= O( H lg H ϵ2 lg 1 ϵ ). Proof. The proof follows from Corollary 2.4 and Lemma 2.7. Corollary 2.9. For all m, f ′ m(u)= O( H lg H ϵ2 lg 1 ϵ ). Proof. The proof follows from Corollaries 2.4, 2.6, and 2.8. We can now ﬁnish the proof of Theorem 2.2. Consider any x-coordinate u, and let m ′ denote the greatest depth of the recursion for which there existed an Im′ (u). Of the jobs in Z that are live at u, let ZR denote those that are resolved during applications of Lemma 2.1, and let ZU denote the rest. The load at u of the boxes used to resolve jobs in ZR is at most LZR (u)+4ϵLZ(u), by Lemma 2.1. The load at u of the boxes used to place jobs in ZU is LZU (u)+ f ′ m′ (u), because jobs in ZU are only placed into free spaces in the various Fm(u)’s, and unused free spaces containing u in Fm(u) for any 0 ≤ m<m ′ are inherited by Fm+1(u). Therefore, using Corollary 2.9 and the fact that LZ(u)= LZR (u)+ LZU (u), the total storage allocated at x-coordinate u does not exceed [ LZR (u)+4ϵLZ(u) ] + [ LZU (u)+ f ′ m′ (u) ] = (1+4ϵ)LZ(u)+ O ( H lg H ϵ2 lg 1 ϵ ) . 3. Dynamic programming solutions. In addition to boxing, our later results use the following results based on dynamic programming to solve simple cases. Theorem 3.1. The optimal makespan can be determined in O(poly(n)(3L)2L+1) time. Proof. First, using the fact that OPT ≤ 3L [5], guess the optimal makespan M ∗. Build an array T with, for each x, an entry for each feasible placement Cx of jobs that cross the vertical line at x. Now deﬁne T [Cx] to be 0–1, with T [Cx] = 1 if and only if the set of jobs that intersect [0,x) can be placed using height at most M ∗ with a placement that respects Cx. We have T [Cx] = 1 if and only if there is a Cx−1 =1 such that Cx−1 is compatible with Cx and T [Cx−1]=1. There are 3L possibilities for M ∗. There are 2n possibilities for x. For each x, there are (M ∗) L ≤ (3L) L conﬁgurations Cx. Computing T [Cx] takes time at most (3L) L. The overall time bound is thus O((3L)(3L) L(3L) Lpoly(n)),Downloaded 12/27/12 to 129.173.72.87. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php 640 BUCHSBAUM, KARLOFF, KENYON, REINGOLD, AND THORUP which is O(poly(n)(3L) 2L+1). Corollary 3.2. Dynamic storage allocation can be solved optimally in polyno- mial time when L = O(lg n/ lg lg n). Proof. The proof follows immediately from Theorem 3.1. Theorem 3.3. Let C be a positive real and let α = α(n) be a positive function of n such that for all suﬃciently large n, α(n) ≥ lg lg n/(C lg n). There is a PTAS for the special case of dynamic storage allocation in which hmin/L ≥ α(n). Proof. Given C, α, and ϵ> 0, apply the dynamic program in the proof of Theorem 3.1 to the same jobs, except with height h replaced by ⌈h/(ϵα(n)L)⌉. Let L ′ be the load in the new problem. If there were no ceiling in the deﬁnition of the new heights, the load in the new problem would be L/(ϵα(n)L)=1/(ϵα(n)). Since each original height h satisﬁes h/(ϵα(n)L) ≥ 1/ϵ, the ceiling introduces an additional factor of at most 1 + ϵ. It follows that L ′ ≤ (1 + ϵ)/(ϵα(n)) ≤ (2C/ϵ)lg n/ lg lg n if n is large enough and ϵ ≤ 1. The new problem can be solved exactly in polynomial time by Corollary 3.2. 4. Algorithm for bounded-height jobs. Let X be the set of all jobs and ϵ be a suﬃciently small positive real. Recall that L is a trivial lower bound to OPT. If all the jobs have the same height, then the problem reduces to interval graph coloring and can be solved optimally in a greedy fashion; furthermore, OPT = L. Our algorithm will be a reduction to this simple case. Let H = hmax⌈1/ϵ⌉, and assume that the maximum height of a job, hmax, is a constant. Algorithm. 1. If L ≤ C 1 ϵ4 lg2 1 ϵ , for some C to be determined later, apply Corollary 3.2 and halt. 2. For each h =1, 2, 3,... ,hmax: (i) Let Xh denote the set of jobs of height h. Let Hh = ⌊H/h⌋h. (ii) Scale each job in Xh down by a factor of h, apply Theorem 2.2 with box- height parameter ⌊H/h⌋ and the given ϵ to this new set of jobs, and then scale the jobs back up by the same factor h. 3. Enlarge the boxes so that they all have height exactly H. Call the new set of boxes B′. 4. Apply the greedy algorithm for interval graph coloring to B′. Theorem 4.1. The makespan of the packing produced by the algorithm is at most (1+15ϵ)OPT. (Recall that hmax is a constant and ϵ is suﬃciently small.) Proof. Assume for now that the algorithm does not stop in step 1. We argue for all t. By Theorem 2.2, step 2 produces a boxing Bh of the jobs of Xh into boxes of height Hh such that LBh(t) ≤ (1+4ϵ)LXh(t)+ O ( 1 ϵ2 · H h (lg H h ) lg 1 ϵ ) h.(4.1) (The ﬁnal h comes from the scaling back up at the end of step (2); we have applied the theorem to jobs of height 1 with box-height parameter there equal to ⌊H/h⌋ = Hh/h.) Let B = B1 ∪ B2 ∪ ··· ∪ Bhmax . Adding (4.1) yields LB(t) ≤ (1+4ϵ)LX (t)+ O (hmax H lg H ϵ2 lg 1 ϵ ) .Downloaded 12/27/12 to 129.173.72.87. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php OPT VERSUS LOAD IN DYNAMIC STORAGE ALLOCATION 641 Enlarging the boxes increases them by at most a factor of 1/(1 − ϵ). All together, makespan = max t LB′ (t) ≤ max t [ 1 1 − ϵ ((1+4ϵ)LX (t)+ O (hmax H lg H ϵ2 lg 1 ϵ ))] ≤ 1+4ϵ 1 − ϵ max t LX (t)+ 1 1 − ϵ O (hmax H lg H ϵ2 lg 1 ϵ ) . Thus, makespan ≤ 1+4ϵ 1 − ϵ L + O (hmax H lg H ϵ2 lg 1 ϵ ) (4.2) ≤ 1+4ϵ 1 − ϵ OPT + O (hmax H lg H ϵ2 lg 1 ϵ ) . Choose C so that the error term O(hmax H lg H ϵ2 lg 1 ϵ ) ≤ ϵL, which is possible under the assumptions that L>C 1 ϵ4 lg2 1 ϵ , hmax is a constant, and H = hmax⌈1/ϵ⌉. If L ≤ C 1 ϵ4 lg2 1 ϵ , then the algorithm stops in step (1), and Theorem 3.1 applies. Otherwise, it follows that makespan ≤ (1+15ϵ)OPT, because L ≤ OPT. Theorem 4.2. The makespan produced by the packing is (1+O(((lg2 L)/L) 1/4))L. (Recall that hmax is a constant.) Proof. Set ϵ = √lg L/L 1/4, and run the algorithm starting in step (2). The claim follows from inequality (4.2). 5. Algorithms for larger jobs. From Theorem 2.2, we can prove the following corollary. Corollary 5.1. Let H be a positive integer box-height parameter, hmin be a positive real, and ϵ> 0 be a suﬃciently small error parameter. Given a set Z of jobs, each of height between hmin and ϵH, there exist a set B of boxes, each of height H, and a boxing of Z into B such that for all x-coordinates t, LB(t) ≤ (1+9ϵ)LZ(t)+ O ( H lg2(H/hmin) ϵ4 ) . Proof. We construct an appropriate boxing. First, round the job heights: each height h is rounded up to ⌊(1 + ϵ) i⌋, where i is deﬁned by (1 + ϵ) i−1 <h ≤ (1 + ϵ)i. Let Y denote the resulting set of rounded jobs. Now partition the jobs according to their heights. For each rounded height h, let Yh denote the set of jobs of height h. Divide the heights of all jobs in Yh by h; apply Theorem 2.2 with box-height parameter ⌊H/h⌋; and then multiply all box heights by h to get a set Bh of boxes of height at most H. The output is a set B = ⋃ h Bh of boxes, which we can assume are all of height H. Let us analyze this construction. There are approximately log(1+ϵ)(ϵH/hmin)= O(lg(H/hmin)/ϵ) parts in the partition. Applying Theorem 2.2 to Yh yields ∀t, LBh(t) ≤ (1+4ϵ)LYh(t)+ O (h ⌊H/h⌋ lg⌊H/h⌋ ϵ2 lg 1 ϵ ) ≤ (1+4ϵ)LYh(t)+ O ( H lg(H/hmin) ϵ3 ) , because hmin ≤ h and lg(1/ϵ) ≤ 1/ϵ. Summing over h,weget ∀t, LB(t) ≤ (1+4ϵ)LY (t)+ O ( H lg2(H/hmin) ϵ4 ) .Downloaded 12/27/12 to 129.173.72.87. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php 642 BUCHSBAUM, KARLOFF, KENYON, REINGOLD, AND THORUP Since rounding increased heights by a factor of 1 + ϵ at most, we have LY (t) ≤ (1 + ϵ)LZ(t). Since (1 + ϵ)(1+4ϵ) ≤ 1+9ϵ for ϵ ≤ 1, the corollary follows. We are now ready to prove our main theorem. Theorem 5.2. For any ﬁxed ϵ ∈ (0, 1] there exists a polynomial-time algorithm, which depends on ϵ, that takes an arbitrary set X of jobs as input and produces a feasible solution to dynamic storage allocation on X with makespan at most (1 + cϵ)L + O(hmax/ϵ 6), where c is a universal constant. Proof. It suﬃces to prove the theorem for ϵ ≤ ϵ0 for some small, positive ϵ0, for the following reason. Suppose for all ϵ ≤ ϵ0 we get a makespan bound of (1 + c0ϵ)L + c1(hmax/ϵ 6) for some constants c0 and c1. Then for ϵ ∈ (ϵ0, 1] we simply use (1 + c0ϵ0)L + c1hmax/ϵ 6 0 ≤ (1 + c0ϵ)L +(c1/ϵ 6 0)hmax/ϵ 6. Similarly, by reducing ϵ by a factor of at most two, we may assume that 1/ϵ ∈ Z. We are going to apply Corollary 5.1 repeatedly, boxing the smallest jobs so as to increase the minimum job height hmin until it gets close enough to the maximum job height hmax that we can ﬁnish with a last application of Corollary 5.1. We argue for all t. Let r denote the ratio hmax/hmin, and recall that L = LX . Assume ﬁrst that lg2 r ≥ 1/ϵ, and set µ = ϵ/ lg2 r and H = ⌈µ 5hmax/ lg2 r⌉. Consider the partition X = Xs ∪ Xℓ, where Xs denotes the jobs of height at most µH and Xℓ = X \\ Xs. Now apply Corollary 5.1 to Xs with box-height parameter H and error parameter µ. This yields a set Bs of boxes of height H into which the jobs of Xs ﬁt such that for some constants c2 and c3, LBs (t) ≤ (1+9µ)LXs (t)+ O ( H lg2(H/hmin) µ4 ) ≤ (1+9µ)LXs (t)+ c2µhmax ≤ LXs (t)+ c3µL(t) = LXs (t)+(c3ϵ/ lg2 r)L(t). Now consider Bs as a set of jobs and the revised problem on X ′ = Bs ∪ Xℓ.For this new problem, the load L ′(t) is at most (1 + c3ϵ/ lg2 r)L(t). Moreover, the new minimum height h′ min is at least µH, and the maximum height remains at most hmax, so we get the new ratio r′ ≤ hmax h′ min ≤ hmax µ⌈µ5hmax/ lg2 r⌉ ≤ hmax µ6hmax/ lg2 r = lg2 r µ6 = lg14 r ϵ6 ≤ lg26 r. Recall that the above construction was conditioned on lg2 r ≥ 1/ϵ.For ϵ suf- ﬁciently small, this implies lg26 r ≤ √r and hence that r′ ≤ √r and also lg2 r′ ≤ lg2 √r ≤ (1/4) lg2 r. Iterate the above boxing of small jobs, each time using new error parameter µ ′ = ϵ/ lg2 r′, until it yields a problem X ∗ with minimum job height h∗ min for which the ratio r∗ = hmax/h∗ min is such that lg2 r∗ < 1/ϵ. Since the ratio decreases by at least a square root each time, this process terminates in polynomial time. Let (r0,... ,rp = r∗) be the sequence of ratios, and let (L0(t),... ,Lp(t)= L ∗(t)) be the sequence of loads. For 0 ≤ i<p we know that Li+1(t) ≤ (1 + c3ϵ/ lg2 ri)Li(t);(5.1) lg2 ri+1 ≤ (1/4) lg2 ri.(5.2)Downloaded 12/27/12 to 129.173.72.87. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php OPT VERSUS LOAD IN DYNAMIC STORAGE ALLOCATION 643 For some constant c4, we therefore get L ∗(t) ≤ L0(t) p−1∏ i=0(1 + c3ϵ/ lg2 ri) by (5.1) ≤ L0(t) exp (p−1∑ i=0(c3ϵ/ lg2 ri) ) ≤ L0(t) exp(c4ϵ/ lg2 rp−1) by (5.2) ≤ L0(t) exp(c4ϵ 2) because lg2 rp−1 ≥ 1/ϵ ≤ (1+2c4ϵ 2)L0(t) for ϵ suﬃciently small. Now apply Corollary 5.1 to all of X ∗ with box-height parameter H = hmax/ϵ (recall that 1/ϵ ∈ Z) and error parameter ϵ; this is the “last application” of Corollary 5.1 to which we alluded earlier. For some constant c, this yields a ﬁnal set X f of jobs of identical height H and with load L f (t)=(1 + 9ϵ)L ∗(t)+ O ( H lg2(H/h∗ min) ϵ4 ) ≤ (1+9ϵ)(1+2c4ϵ 2)L0(t)+ O ( H lg2(H/h∗ min) ϵ4 ) ≤ (1 + cϵ)L0(t)+ O ( hmax lg2(r∗/ϵ) ϵ5 ) . Noting that lg2 r∗ < 1/ϵ and lg2(1/ϵ) < 1/ϵ for ϵ suﬃciently small, we derive lg2(r∗/ϵ) ≤ 4/ϵ. Therefore L f (t) ≤ (1 + cϵ)L0(t)+ O(hmax/ϵ 6). Corollary 5.3. There exists a polynomial-time algorithm that takes an arbitrary set X of jobs as input and produces a feasible solution to dynamic storage allocation on X with makespan at most (1 + O((hmax/L) 1/7))L. Proof. Apply Theorem 5.2 to X with ϵ =(hmax/L) 1/7. Corollary 5.4. Fix some function f (m)= o(m). Then there is a PTAS for dynamic storage allocation when hmax ≤ f (L). Proof. Given ϵ> 0, there is an L0 such that f (L) ≤ ϵ 7L for all L ≥ L0.If L<L0, use the dynamic program of Theorem 3.1. If L ≥ L0, then hmax ≤ f (L) ≤ ϵ 7L. Apply the algorithm of Theorem 5.2. The error term of Theorem 5.2 is O(hmax/ϵ 6) ≤ c ′ϵL for some constant c ′. Hence the makespan of the schedule is at most (1 + (c + c ′)ϵ)L. Theorem 5.5. For all ϵ> 0, there exists a polynomial-time (2+ϵ)-approximation algorithm for dynamic storage allocation. Proof. Consider some small positive δ to be determined later. Let X = Xs ∪ Xℓ, where Xs is the set of jobs of height less than δ7L and Xℓ = X \\ Xs. Use Theorem 5.2 with error parameter δ to pack the jobs in Xs, yielding a (1 + c ′δ)-approximation for some constant c ′. Apply the (1 + δ)-approximation algorithm implied by Theorem 3.3 with the same δ to pack the jobs in Xℓ, which is possible because the load divided by the minimum height is at most 1/δ7, which is certainly at most C lg n/ lg lg n for C =1/δ7; this yields a (1 + δ)-approximation. Choose δ so that δ(c ′ +1) = ϵ.Downloaded 12/27/12 to 129.173.72.87. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php 644 BUCHSBAUM, KARLOFF, KENYON, REINGOLD, AND THORUP 6. Lower bounds for OPT − LOAD. Fix a positive integer d. Given a bipartite multigraph G =(X, Y, E), X = Y = {1, 2,... ,n}, build an instance of dynamic storage allocation as follows. Start with n rectangles of height d, with xi =0, yi = i for i =1, 2,... ,n, and then add n more rectangles of height d, with xi =3n−i, yi =3n for i =1, 2,... ,n. Call these 2n items d-items. For each e =(j, k) ∈ E (with multiplicity, as E is a multiset), 1 ≤ j, k ≤ n, add one item of height 1 having xi = j, yi =3n − k. Call these jobs 1-items. These are all the jobs. Call the instance I. Lemma 6.1. If G is d-regular, then LI (t) ≤ dn for all t ∈ (0, 3n). Proof. For any noninteger t ∈ [n, 2n], the statement of the lemma is obvious, since the set of jobs that intersect (n, 2n) is the set of all 1-items, that set has size dn, and each such job has height 1. For any noninteger t ∈ [0,n], let j = ⌊t⌋. Crossing t are n − j d-items (these jobs have xi = 0) and dj 1-items (these have xi ∈{1, 2,... ,j}), because G is d-regular, and no others. Hence the load at t is (n − j) · d +(dj) · 1= dn. For a noninteger t ∈ [2n, 3n], the argument is symmetric to the case of t ∈ [0,n]. For any integer t ∈ (0, 3n), LI (·) achieves a local minimum at t. Lemma 6.2. For any positive integers n, d, f , and s< n1/2−1/f √d , there exists a d-regular bipartite multigraph (X, Y, E) with X = Y = {1,... ,n} such that for any subsets X ′ of s consecutive vertices from X and Y ′ of s consecutive vertices from Y , the number of edges induced by X ′ ∪ Y ′ is smaller than f . Proof. Consider the following probability space of n-vertex-by-n-vertex d-regular bipartite multigraphs. Choose d independent permutations π of {1,... ,n}; for each, add edges between i ∈ X and π(i) ∈ Y for 1 ≤ i ≤ n. We will show that the probability that a graph not of the claimed structure exists is less than 1; the claim then follows. Consider such a graph G =(X, Y, E). There are some j and k such that X ′ = {j,... ,j + s − 1}⊆ X, Y ′ = {k,... ,k + s − 1}⊆ Y , and the subgraph induced by X ′ ∪ Y ′ has at least f edges. Consider any f such edges and ﬁx an arbitrary order of them; this forms a sequence of edges F =((u1,v1),... , (uf ,vf )), where each ui ∈ X ′ and each vi ∈ Y ′. There are no more than n2 choices for the pair (j, k) and no more than s 2f possible sequences F . The probability that any particular edge exists is at most d/n. By the union bound, the probability that G exists is therefore no more than P = n2s 2f (d/n) f . Simple algebra yields P< 1 when s< n1/2−1/f √d . Theorem 6.3. For all positive integers n and d, there is an instance of dynamic storage allocation with maximum job height d, L(t) ≤ dn for all t, and OPT−LOAD ≥ n1/2−1/⌈d/2⌉ 12√d . Proof. Let G =(X, Y, E)bea d-regular bipartite multigraph such that |X| = |Y | = n. Build the instance I associated with G, as above, with 2n d-items and dn 1-items. Lemma 6.1 shows that the load is at most dn everywhere. Assume an optimal solution, and denote by Z the region deﬁned by the isothetic bounding box of the d-items. Z is the rectangle [0, 3n] × [min, max], where min is the minimum y-coordinate of the bottoms of the 2n d-items and max is the maximum y-coordinate of the tops of the 2n d-items. Deﬁne Z ′ to be the set of 1-items placed outside Z. Because max − min ≥ dn and the load is at most dn everywhere, it follows that the load of Z ′ lower bounds OPT − LOAD and that the area of the jobs in Z ′ lower bounds the empty space inside Z. Now, for any positive real s<n, assume that fewer than s/12 1-items are placed outside Z and also that max − min <dn + s/12. The area of Z is thus (max − min)(3n) < (dn + s/12)(3n). The total area of all the jobs is (dn)(3n). There-Downloaded 12/27/12 to 129.173.72.87. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php OPT VERSUS LOAD IN DYNAMIC STORAGE ALLOCATION 645 fore, if all the jobs were placed in Z, the empty space in Z would be at most (s/12)(3n). For each job placed outside Z, the empty space inside Z grows by at most 3n. The total empty space inside Z is thus less than 2(s/12)(3n)= sn/2. Consider a d-item to be comprised of d unit-height rows, which are placed con- tiguously in the plane. Deﬁne the left (resp., right) d-items to be those whose left (resp., right) endpoints are 0 (resp., 3n). Call region (3n − 1, 3n) × (k, k + 1) for any integer k ∈ [min, max −1] a right gap if it is unoccupied by every right d-item. Clearly OPT − LOAD is at least the number of right gaps, so we may assume this number is less than n/2. It follows that at least n/2 left d-items are adjacent to no right gaps; i.e., for each such left d-item x, there is a row of some right d-item to the right of each one of x’s d rows. Call these the good left d-items. For any left d-item J, deﬁne its neighbor right d-items to be the (at most two) right d-items whose y-coordinates overlap with J, and call the actual rows of those neighbors that occupy the same y-coordinates as J its neighbor right rows. Because there are at least n/2 good left d-items and the total empty space inside Z is less than sn/2, there must be at least one good left d-item J with less than s empty space between it and its neighbor right rows. Because s<n, there is some 1-item x placed between each row of J and the corresponding neighbor right row; furthermore, the left endpoint of x is within s−1 of the right endpoint of J, and the right endpoint of x is within s − 1 of the left endpoint of the corresponding neighbor right row. For one of the at most two neighbor right d-items K of J, there are at least ⌈d/2⌉ neighbor right rows of J belonging to K.In G, therefore, there are subsets of ⌊s⌋ consecutive vertices of X (starting at vertex j ∈ X, where j is the right endpoint of J) and ⌊s⌋ consecutive vertices of Y (starting at vertex k −⌊s⌋ +1 ∈ Y , where k is the left endpoint of K) with at least ⌈d/2⌉ edges between them, corresponding to these 1-items. If s< n1/2−1/⌈d/2⌉ √d , Lemma 6.2 (with f = ⌈d/2⌉) shows that there is some G′ without such a window of edges. By contradiction, therefore, for any such G′ there must be at least s/12 1-items placed outside Z, or else max − min ≥ s/12; in either case, OPT − LOAD ≥ s/12. The theorem follows by choosing s = n1/2−1/⌈d/2⌉ √d and noting that in fact OPT − LOAD ≥⌈s/12⌉. Corollary 6.4. For any ϵ> 0, there exist c, d > 0 such that for all suﬃciently large integers L, there is an instance of dynamic storage allocation with maximum job height d, L(t) ≤ L for all t, and OPT − LOAD ≥ cL 1/2−ϵ. Proof. Fix d = ⌈2/ϵ⌉, and choose a large L ∈ Z. Deﬁne n, r ∈ Z such that n> 0, 0 ≤ r< d, and L = nd + r. Deﬁne L ′ = nd. By Theorem 6.3, there is a dynamic storage allocation instance I with maximum job height d, LI (t) ≤ L ′ = dn for all t, and ∆ = OPT − LOAD ≥ n1/2−1/⌈d/2⌉ 12√d . Because n = L−r d ≤ L d , it follows that LI (t) ≤ L for all t; and because n ≥ L 2d , it follows that ∆ ≥ n1/2−1/⌈d/2⌉ 12√d ≥ ( L 2d )1/2−1/⌈d/2⌉ 12√d = 1 12√d ( 1 2d )1/2−1/⌈d/2⌉ L 1/2−1/⌈d/2⌉. The claim follows by setting c = 1 12√d ( 1 2d )1/2−1/⌈d/2⌉ and noting that 1/⌈d/2⌉≤ ϵ. Corollary 6.5. For any ϵ> 0, there exists a c ′ > 0 such that for all suﬃciently large integers hmax, there is a dynamic storage allocation instance with maximum jobDownloaded 12/27/12 to 129.173.72.87. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php 646 BUCHSBAUM, KARLOFF, KENYON, REINGOLD, AND THORUP height hmax, maximum load at most L, and OPT − LOAD ≥ c ′(hmax/L) 1/2+ϵL, for inﬁnitely many integers L. Proof. Given ϵ> 0, deﬁne h = h(ϵ) and c> 0 so that for all suﬃciently large L0, Corollary 6.4 yields a dynamic storage allocation instance with maximum job height h, maximum load at most L0, and optimum makespan OPT0 ≥ L0 + cL 1/2−ϵ 0 . Set c ′ = c/h 1/2+ϵ. For all integers L and hmax such that L and L/hmax are suﬃciently large and hmax/h and L/(hmax/h) are integral, set L0 = L/(hmax/h). Now scale up the instance by hmax/h. The new optimum makespan is OPT =(hmax/h)OPT0. The new load is at most L0hmax/h = L, and OPT =(hmax/h)OPT0 ≥ (hmax/h)(L0 + cL 1/2−ϵ 0 ) = L +(hmax/h)cL 1/2−ϵ 0 = L(1+(hmax/(hL))cL 1/2−ϵ 0 ) = L(1+(hmax/(hL))c(hL/hmax) 1/2−ϵ) = L(1+(c/h 1/2+ϵ)(hmax/L) 1/2+ϵ) = L(1 + c ′(hmax/L) 1/2+ϵ). Acknowledgments. We thank the anonymous referees for several helpful com- ments. REFERENCES [1] M. Chrobak and M. Slusarek, On some packing problem related to dynamic storage allocation, RAIRO Inform. Theor. Appl., 22 (1988), pp. 487–499. [2] M. de Berg, M. van Krevald, M. Overmars, and O. Schwarzkopf, Computational Geome- try: Algorithms and Applications, 2nd ed., Springer-Verlag, Berlin, 2000. [3] M. R. Garey and D. S. Johnson, Computers and Intractability: A Guide to the Theory of NP-Completeness, W. H. Freeman and Company, San Francisco, 1979. [4] J. Gergov, Approximation algorithms for dynamic storage allocation, in Algorithms—ESA 1996, Lecture Notes in Comput. Sci. 1136, J. Diaz and M. J. Serna, eds., Springer-Verlag, Berlin, 1996, pp. 52–61. [5] J. Gergov, Algorithms for compile-time memory optimization, in Proceedings of the 10th ACM-SIAM Symposium on Discrete Algorithms, Baltimore, MD, SIAM, Philadelphia, 1999, pp. 907–908. [6] H. A. Kierstead, The linearity of ﬁrst-ﬁt coloring of interval graphs, SIAM J. Discrete Math., 1 (1988), pp. 526–530. [7] H. A. Kierstead, A polynomial time approximation algorithm for dynamic storage allocation, Discrete Math., 88 (1991), pp. 231–237. [8] D. R. Woodall, Problem no. 4, in Proceedings of the British Combinatorial Conference (1973), London Math. Soc. Lecture Note. Ser. 13, Cambridge University Press, Cambridge, UK, 1974, p. 202.Downloaded 12/27/12 to 129.173.72.87. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php","libVersion":"0.2.3","langs":""}