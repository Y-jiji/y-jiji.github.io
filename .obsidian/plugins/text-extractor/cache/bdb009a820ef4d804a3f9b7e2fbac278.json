{"path":"_assets/qecv.pdf","text":"QECV : A VERIFICATION FRAMEWORK FOR QUANTUM ERROR CORRECTION CODES A PREPRINT Anbang Wu Department of Computer Science University of California, Santa Barbara anbang@ucsb.edu Gushu Li Department of Electrical & Computer Engineering University of California, Santa Barbara gushuli@ece.ucsb.edu Hezi Zhang Department of Computer Science University of California, Santa Barbara hezi@ucsb.edu Gian Giacomo Guerreschi Intel Labs Santa Clara, California gian.giacomo.guerreschi@intel.com Yuan Xie Department of Electrical & Computer Engineering University of California, Santa Barbara yuanxie@ucsb.edu Yufei Ding Department of Computer Science University of California, Santa Barbara yufeiding@cs.ucsb.edu November 30, 2021 ABSTRACT Quantum Error Correction (QEC) is essential for the functioning of large-scale fault-tolerant quantum computers, and its implementation is a very sophisticated process involving both quantum and classical hardware. Formulating and verifying the decomposition of logical operations into physical ones is a challenge in itself. In this paper, we propose QECV, a veriﬁcation framework that can efﬁciently verify the formal correctness of stabilizer codes, arguably the most important class of QEC codes. QECV ﬁrst comes with a concise language, QECV-Lang, where stabilizers are treated as a ﬁrst-class object, to represent QEC programs. Stabilizers are also used as predicates in our new assertion language, QECV-Assn, as logical and arithmetic operations of stabilizers can be naturally deﬁned. We derive a sound quantum Hoare logic proof system with a set of inference rules for QECV to efﬁciently reason about the correctness of QEC programs. We demonstrate the effectiveness of QECV with both theoretical complexity analysis and in-depth case studies of two well-known stabilizer QEC codes, the repetition code and the surface code.arXiv:2111.13728v1 [quant-ph] 26 Nov 2021 QECV: A Veriﬁcation Framework for Quantum Error Correction Codes A PREPRINT 1 Introduction Quantum error correcting (QEC) codes [1, 2, 3] are vital for imple- menting fault-tolerant quantum computation and overcoming the noise present in quantum hardware [4, 5]. Quantum device vendors are exploring various quantum error correction codes to boost the error tolerance of quantum computation. For example, Google ex- ploits the repetition code [6] to suppress errors in their Sycamore device [7], IBM extends the surface code [1] to their low-degree superconducting quantum computers [8], and Amazon utilizes the concatenated cat code [2] to build a fault-tolerant qubit. A central concept in QEC code design is that of a “stabilizer” [9]. The term refers to a quantum operator which expresses the correla- tions present among the physical qubits forming the logical qubit. Operations to encode logical states or detect and correct errors can be derived once the stabilizers of the QEC code are provided. In a stabilizer code, these primitive operations over logical qubits con- sist of quantum programs, one for each primitive. As an example, Fowler et al. [1] developed a series of programs on the surface code to implement the primitive operations (e.g., a logical X gate, H gate, and CNOT gate) necessary for universal fault-tolerant quan- tum computation. While executing these primitives, any stabilizer code implementation requires frequent measurements of the phys- ical qubits to detect possible hardware errors and, thus, apply the appropriate correction operation. When analyzing the correctness of a stabilizer code, there are two key aspects that need to be considered: 1) the correctness of the logical operation: The stabilizer code must implement the desired logical operation over the logical qubits by applying several physi- cal operations over the consituent physical qubits. 2) the capability of error correction: When hardware errors happen, there exist pro- tocols for error decoding and correction which are based on the information extracted by measurements in QEC codes. To the best of our knowledge, there is no formal veriﬁcation frame- work for QEC codes yet. Previous works on quantum error correc- tion [1, 3, 10, 11, 12] demonstrate the correctness of the proposed QEC protocol by numerical simulation on QEC programs. How- ever, this approach does not provide formal proof for the correct- ness of QEC codes. We asked ourselves the question: Can one formally verify QEC codes using existing veriﬁcation frameworks for general quantum programs since QEC codes are effectively a kind of quantum program? In this vein, one well-developed method for quantum program ver- iﬁcation [13, 14, 15] is to use dynamic techniques such as quantum simulation. This category of methods can accurately characterize the quantum state evolution of small quantum programs but can not scale up to large quantum programs with more than 50 qubits due to the exponential computation overhead [13]. This poor scal- ability of dynamic methods makes it inefﬁcient for the veriﬁcation of QEC codes since a reasonably fault-tolerant logical qubit would inevitably involve many physical qubits [1]. Another type of veriﬁcation works [16, 17, 18, 19, 20, 21, 22], ex- ploits static analysis techniques to reason about quantum programs. These works all naturally incur exponential computation overhead since they need to track the evolution of some Hermitian matrices, which are of dimension O(4 n) for a n-qubit system. Yu and Pals- berg [23] recently proposed a computationally efﬁcient quantum abstract interpretation technique to reason about the correctness for certain kinds of assertions. Yet, trading in accuracy is not suitable for the veriﬁcation of QEC codes which requires exact correctness. Thus, our answer to the question above is: No, adopting general veriﬁcation frameworks sacriﬁces either scalability or accuracy. To this end, we build a formal veriﬁcation framework crafted for quantum stabilizer codes to squeeze out the best veriﬁcation ef- ﬁciency without compromising accuracy. Our approach rests on a central idea: while realizing scalable veriﬁcation for a general quantum program is hard, it might be possible to efﬁciently ver- ify the QEC codes with a delicate separation between the hard and easy parts in the veriﬁcation process. We observe that most parts in verifying QEC codes turn out to fall into the easy region be- cause they can be efﬁciently processed by preserving the high-level stabilizer information. In particular, stabilizers provide a compact description for QEC codes [9]. Major components in QEC codes, e.g., error channels, Clifford gates, and parity measurements can all be described within the stabilizer formalism. Besides, it only takes O(n2) complexity to emulate Clifford operations on stabi- lizers [6]. Using stabilizers as predicates, we can potentially avoid unnecessary exponential computation overhead in general quantum program reasoning. We ﬁrst propose a concise QEC programming language, QECV- Lang, where stabilizers are treated as ﬁrst-class objects. This al- lows QECV-Lang to represent in an intuitive and compact form different operations in the QEC implementation, ranging from en- coding to decoding and to error correction. We develop operational semantics and denotational semantics for QECV-Lang, which lays the foundation for building up the syntax-directed veriﬁcation sys- tem. One key enabler for our semantics design is the separation between quantum states of the physical qubits and the informa- tion captured by the stabilizers. It describes the former with partial density matrices and treats the latter as a classic program state. It signiﬁcantly simpliﬁes the computations associated with the stabi- lizers by avoiding the direct description of how the stabilizers are measured and instead focusing on how the high-level information is used in the decoding stage. We further develop a new assertion language, named QECV-Assn, in which the predicates are deﬁned by stabilizers. To enhance the logical expressive power, we introduce not only the standalone sta- bilizers, but also the arithmetic and logical expressions of them for expressing assertions. The key insight behind such a design is to form a universal state space for veriﬁcation, as a standalone sta- bilizer could not represent the whole state space. We also remark that, despite our QECV-Lang and QECV-Assn are crafted for QEC codes, their design allows for broader applicability. Any quantum programs and quantum predicates that could be expressed in the quantum while-language [16] and Hermitian-based predicates [19] can also be expressed in our languages. With such an elegant prop- erty, our languages could potentially serve as the common foun- dation of both general quantum programs and QEC designs. It will therefore avoid the dilemma of choosing between a general 2 QECV: A Veriﬁcation Framework for Quantum Error Correction Codes A PREPRINT but less effective language or a domain-speciﬁc but more effective language. Together with QECV-Lang and QECV-Assn, we further establish a sound quantum Hoare logic for QEC programs. This proof system can demonstrate exponential time and space saving for most QEC operations (e.g., state preparation, Pauli gates, and error detec- tion) when, in a real QEC program, the predicate formulae is com- mutable with the stabilizer variable in our quantum Hoare logic. Even for the most challenging veriﬁcation of the logical T gate implementation, our proof system may still have this strong advan- tage, depending on the actual T gate implementation of the target QEC code. We give both theoretical analysis and detailed case studies for evaluating the proposed framework. We ﬁrst compare QECV with the vanilla quantum Hoare logic [16] and quantum while- language [16] in terms of the complexity when describing and ver- ifying the quantum stabilizer codes. We then give very detailed, step-by-step case studies of two well-known QEC codes. This al- lows the reader to familiarize the concepts behind our framework and its usage for verifying the correctness of quantum stabilizer codes. To summarize, our major contributions are as follows: • We propose QECV-Lang, a concise programming lan- guage for QEC codes and give a full speciﬁcation of its syntax and operational/denotational semantics. • We formulate a new assertion language QECV-Assn. It is the ﬁrst effort that exploits stabilizers for building univer- sal assertions on quantum states. • We develop a sound quantum Hoare logic framework based on QECV-Assn and QECV-Lang with a set of in- ference rules to verify the correctness of QEC programs. • We demonstrate the effectiveness of our framework with both theoretical complexity analysis and in-depth case studies of two well-known stabilizer QEC codes. 2 Background In this section, we introduce the background for our work. We sum- marize our key notations in Table 1. We do not cover the basics of quantum computing (e.g., density operator, unitary transformation) and recommend [6] for reference. Table 1: Notation used in this paper. q , ¯q qubits, a set of qubits, respectively; |ψ ⟩, |ϕ⟩, |0⟩, |1⟩, |+ ⟩, |−⟩ pure quantum states; ρ, |ψ ⟩⟨ψ | density operators; U unitary transformations; O , M Observable; Use M to stress measurement; H the Hilbert space of quantum states; D (H ) the set of partial density operators on H ; 2.1 Quantum Error Correction and Stabilizer Most QEC codes consist of three stages: encoding, decoding, and error correction. The encoding protocol projects an unprotected state of the data qubits into the subspace generated by the logical states. The decoding protocol detects potential errors by perform- ing parity measurements on data qubits. Finally, the correction pro- tocol removes the errors by driving the quantum state back to the logical subspace. Stabilizer. The stabilizer formalism proposed by Gottesman [9] provides a unifying description of many QEC codes. Given a n- qubit state |ψ⟩ and a Pauli string s ∈ ⊗ n{I, X, Y, Z}, we say that s is a stabilizer of |ψ⟩, or |ψ⟩ is stabilized by s, if s|ψ⟩ = |ψ⟩. When the stabilized state |ψ⟩ is clear in the context, we will simply say that s is a stabilizer, without referring to the stabilized state. We then can use multiple stabilizers to naturally identify a sub- space, which is the intersection of the stabilizers’ projection sub- spaces, to represent the logical states. Moreover, stabilizers can also be observables and they can be measured to ascertain whether the state of the data qubits is in the correct subspace. These mea- surements are called stabilizer measurements. Another advantage of the stabilizer formalism is that it can describe standard quantum error channels on stabilized states. Once the stabilizers are deter- mined, the QEC encoding, decoding, and error correction can be easily derived. Due to the centrality of stabilizers in QEC codes, including them as fundamental concepts of the veriﬁcation framework is a promis- ing direction. Beneﬁting from the expressiveness of the stabilizer formalism, we believe that our veriﬁcation framework for quantum stabilizer codes will be applicable to many existing QEC codes and will help designing novel implementations of fault-tolerant opera- tions. In the writing time of this paper, we also notice that Rand, Sun- daram, Singhal and Lackey [24, 25, 26] develop an elegant type- checking system for general quantum programs based on the sta- bilizer formalism. Despite that we share same high-level insights in utilizing stabilizer formalism [9], we differ signiﬁcantly in the overall optimization goal and the entire design framework. In ad- dition, their work only consider quantum circuits and cannot deal with branch statements (e.g., if and while). These statements are in- dispensable for QEC programs. In contrast, we can handle branch statements by incorporating stabilizer variables in the design of quantum predicate logic. Last but not least, this paper also de- velops a compact language for QEC programs while their work follows the vanilla quantum circuit language [6]. 2.2 Quantum Program Language The quantum while-language proposed by Ying [16] provides a universal description of purely-quantum programs without classi- cal variables. It focuses on characterizing basic quantum program structures and its syntax is deﬁned in Backus-Naur form as follows: 3 QECV: A Veriﬁcation Framework for Quantum Error Correction Codes A PREPRINT Prog ::= skip | q := |0⟩ | ¯q := U [¯q] | Prog1; Prog2 | case M [¯q] = m → Progm end | while M [¯q] = 1 do Prog1 done Here Prog plays the role of a statement of the quantum while- language, but can also indicates the full program when seen as a sequence of statements. In the expressions above, q denotes a quan- tum variable and ¯q represents a quantum register associated with a ﬁnite number of quantum variables. The language constructs above are explained as follows: (1) skip does nothing; (2) q := |0⟩ pre- pare quantum variable q in state |0⟩; (3) ¯q := U [¯q] perform uni- tary operation U on the quantum registers ¯q; (4) Prog1; Prog2 is the sequencing of statements; (5) case M [¯q] = m → Progm end measures the quantum variables in ¯q with semi-positive Hermi- tian operators M = {M0, M1, · · · , Mm} and executes program Progm if the measurement outcome is m; (6) while M [¯q] = 1 do Prog1 done measures qubits ¯q and executes Prog1 if the mea- surement outcome is 1. If the measurement outcome is 0, the while loop terminates. Here M is assumed to have only two possible outcomes, m = 0, 1. The semantics of quantum while-language is developed by assum- ing partial density operators as quantum program states. The de- tails can be found in [16]. 2.3 Quantum Hoare Logic and Quantum Predicates Quantum Hoare logic [16] provides a syntax-directed proof system for reasoning about quantum program correctness. The basic com- puting unit of quantum Hoare logic is the Hoare tripe, which is in the form of {A}Prog{B}. Here A and B are quantum predicates, Prog is the quantum program. A is often called precondition while B is called post-condition. The general meaning of the quantum Hoare tripe is that, if the input state satisﬁes A, then the output state of Prog satisﬁes B. The exact mathematical interpretation of the quantum Hoare tripe depends on the type of the predicates used. A general quantum predicate is a Hermitian operator O [16] where 0 ≤ T r(Oρ) ≤ 1, ∀ρ ∈ D(H). A quantum state ρ satisﬁes the quantum predicate O depending on the value of T r(Oρ), which represents the expectation value of O on state ρ. In practice, mea- suring T r(Oρ) can be very time-consuming . This can be avoided by restricting the predicate from a general Hermitian operator to a projection operator P with the property that P 2 = I. We say that a quantum state ρ satisﬁes predicate P (denoted by ρ |= P ) if P ρ = ρ. A projection operator P can also be described by its sub- space with eigenvalue +1, namely SP = {|ψ⟩s.t.|ψ⟩ = P |ψ⟩} in the qubits’ Hilbert space H. Birkhoff and Neumann [27] deﬁne a quantum logic on the set of subspaces in H in which, for example, the logical and corresponds to the intersection of subspaces. This construction induces logic operations on projection operators by considering the equivalent operation on the associated subspaces. 3 QECV-Lang In this section, we introduce QECV-Lang, a concise language for QEC Programs. We deﬁne its syntax, operational semantics, and denotational semantics. 3.1 Syntax We restate the notation for quantum variables as follows: Deﬁne qVar as the set of quantum variables, q as a metavariable ranging over quantum variables, and ¯q to be a quantum register associated with a ﬁnite set of distinct quantum variables. We denote the state space of q by Hq which is a two-dimensional Hilbert space spanned by the computational basis states {|0⟩, |1⟩}. The state space of ¯q is the tensor product of Hilbert spaces H¯q = ⊗q∈¯qHq. Logical operations in QEC codes are often associated with changes in the set of stabilizer measurements. For example, the surface code [1] frequently turns on and turn off speciﬁc stabilizer mea- surement circuits to implement logical gates. Besides, the out- comes of stabilizer measurements act as signals for error correc- tion. By introducing a stabilizer variable, which represents a stabi- lizer measurement circuit without the need of specifying its actual implementation, we can greatly simplify the description of QEC programs. We deﬁne the notations for the stabilizer variable as fol- lows: Deﬁne S as the set of stabilizers on qVar, s as an individual stabi- lizer in S, sVar as the set of stabilzer variables, and ∫ as a metavari- able ranging over sVar. To avoid S being uncountable, we assume that every s ∈ S only involves a ﬁnite number of qubits. The range of values for the stabilizer variable ∫ is S ∪ −S ∪ iS ∪ −iS, where i is the imaginary unit. We deﬁne the syntax of QECV-Lang as follows: Prog ::= skip | q := |0⟩ | ¯q := U [¯q] | ∫ := s u e | Prog1; Prog2 | if M [∫ , ¯q] then Prog1 else Prog0 end | while M [∫ , ¯q] do Prog1 done s u e ::= ±s | ±i s | ±∫ The proposed language constructs consisting of instructions as fol- lows: (1) skip does nothing; (2) q := |0⟩ resets quantum variable q to ground state |0⟩; (3) ¯q := U [¯q] perform unitary operation U on quantum register ¯q; (4) ∫ := s u e assigns a unary stabilizer ex- pression s u e to the stabilizer variable ∫ ; (5) Prog1; Prog2 is the se- quencing of programs; (6) if M [∫ , ¯q] then Prog1 else Prog0 end perform the stabilizer measurement represented by ∫ on qubits ¯q (or in short, measures ∫ on qubits ¯q) measures qubits in ¯q with the stabilizer ∫ and executes program Prog1 if the measurement out- come is 1. If the measurement outcome is −1, i.e. the measured state is in the -1 eigenspace of ∫ , we ﬁrst execute ∫ = −∫ which ﬂips the sign of ∫ , then execute Prog0. We can see (6) as a short- term for if M [∫ , ¯q] = 1 then Prog1 else ∫ := −∫ ; Prog0 end. (7) while M [∫ , ¯q] do Prog1 done measures ∫ on qubits ¯q, and perform Prog1 if the measurement outcome is 1. If the measurement out- 4 QECV: A Veriﬁcation Framework for Quantum Error Correction Codes A PREPRINT (a) ∫0 := Z0Z1Z2Z3 if M [∫0, q3q2q1q0] then skip else // correct error.... · · · // Recover signal ∫0 := −∫0 (b) Figure 1: An example for QECV-Lang. (a) is the stabilizer mea- surement for Z0Z1Z2Z3. (b) is an error correction program asso- ciated with (a). The detailed error correction operation depends the error correction protocol and are omitted here. come is -1, the sign of ∫ will be ﬂipped automatically, and then the while loop terminates. The language constructs above are similar to those of the quantum while-language, except the part associated with stabilizer variables. Stabilizer variables can be used to describe operations on stabiliz- ers. For example, to turn off one stabilizer measurement circuit in a QEC program, we can simply set ∫ = I. The stabilizer variable can also serve to inform the error correction procedure. Every time we detect one or more stabilizer variables with a negative sign (this may happen after a stabilizer measurement), the decoder knows that at least one error affected the physical circuit. It proceeds to identifying the speciﬁc error and applies the corresponding correc- tion. We deﬁne the error correction protocol as a function over stabilizer variables as follows: Deﬁnition 3.1 (Error correction protocol). Deﬁne correct(∫0, ∫1, · · · ) as an error decoding and correction protocol by measuring ∫0, ∫1, · · · . As an example, we present a snippet of QECV-Lang code that cor- responds to one stabilizer measurement of the surface code, where the parity qubit s is connected to four data qubits {q0, q1, q2, q3} with one Z-type stabilizer. Figure 1(a) shows the target stabilizer measurement circuit, while panel (b) shows an error correction pro- gram based on the stabilizer measurement in (a). The basic idea of the program in Figure 1(b) is that, if the state of q0q1q2q3 is not stabilized by the stabilizer variable ∫0, then some errors have hap- pened and the QEC program should correct them. Comparing to the quantum while-language, QECV-Lang avoids the explicit introduction of parity qubits and the implementation of sta- bilizer measurement circuits. Instead, it simply provides the stabi- lizer to measure as the value of variable ∫ . This approach makes QECV-Lang programs very ﬂexible and independent from the spe- ciﬁc implementation of stabilizer measurements. The latter would, for example, depend on architectural properties like the underlying hardware connectivity [3]. While being optimized for QEC codes, QECV-Lang contains all the program constructs necessary to describe general quantum pro- grams. Actually, all programs in quantum while-language can be translated into QECV-Lang by setting the stabilizer variable to a Pauli Z operator when qubits need to be measured. 3.2 Operational Semantics The operational semantics of the proposed QECV-Lang are pre- sented in Figure 2. Different from the quantum while-language, QECV-Lang denotes the state in QEC programs by the tuple (ρ, σ), where ρ is a partial density matrix that describes the current state of ¯q , and σ represents the current state of stabilizer variables. The quantum state ρ can be regarded as a function over quantum variables q, and ρ(q) represents the reduced partial density matrix where quantum variables except q are all traced out. Likewise, σ represents a function over stabilizer variables, and σ(∫ ) is deﬁned to be the current value of ∫ . The stabilizer state σ is functionally similar to the classical program state [28], and we can deﬁne the substution rule for σ in a similar way, which is then used in Fig- ure 2. Deﬁnition 3.2 (Substitution rule). The substitution rules for stabi- lizer state σ are deﬁned as follows, σ[s/∫i](∫j) = {s, if i = j; σ(∫j), otherwise . Rules in Figure 2 are self-explained and represent reformulation of concepts familiar in quantum computing. The notation in these rules follows the convention in programming language research, for example, the expressions over the bar in the inference rules are premises while the expression under the bar is conclusion. For pure quantum state operations in Figure 2, the operational semantics fol- lows the ﬂow in quantum while-language [16]. For stabilizer re- lated operations, we introduce extra operational semantics for the unary stabilizer expression s u e , as shown in the top right corner of Figure 2. We then process the assignment operation on stabilizer variables with the substitution rule. When measuring the stabilizer variable ∫ , its sign will get ﬂipped if the current quantum state is not a +1 eigenstate of ∫ . Thus, we include one operation in the “If -1” and “While -1” rule to take care of the sign ﬂipping on ∫ . To illustrate the use of the operational semantics in Figure 2, we revisit the program in Figure 1(b). We use (0, {}) to represent the initial state of (ρ, σ) before the program. Example 3.3 (Error correction experiment). Assume the initializa- tion q3q2q1q0 := |0000⟩ on data qubits is distorted by noise and data qubits are assigned to be |0001⟩. This may happen when, after the initialization in the logical subspace, a Pauli X error af- fects one of the qubits. For illustration purposes we consider that such error was on qubit q0 and therefore use q0 := Xq0; to cor- rect the error. Notice that, in general, the error correcting protocol correct(∫0, · · · ) depends on the outcome of multiple stabilizer mea- surements. The program in Figure 1(b) then becomes Prog ≡ q3q2q1q0 := |0001⟩; ∫0 := Z0123; if M [∫0, q3q2q1q0] then skip else q0 := Xq0; ∫0 := −∫0 end. We write Z0Z1Z2Z3 as Z0123 for simplicity. Then the evaluation of Prog with the operational semantics proceeds as follows: ⟨Prog, ρ⟩ = ⟨q3q2q1q0 := |1110⟩; ∫0 := Z0123; if M [∫0, q3q2q1q0]then skip else q0 := Xq0; ∫0 := −∫0 end, (0, {})⟩ → ⟨∫0 := Z0123; if M [∫0, q3q2q1q0] then skip else q0 := Xq0; ∫0 := −∫0 end, (|0001⟩⟨0001|, {})⟩ 5 QECV: A Veriﬁcation Framework for Quantum Error Correction Codes A PREPRINT (Skip) ⟨skip, (ρ, σ)⟩ → ⟨E, (ρ, σ)⟩ (Initialization) ⟨q := |0⟩, (ρ, σ)⟩ → ⟨E, (ρq 0, σ)⟩ (Unitary) ⟨¯q := U [q], (ρ, σ)⟩ → ⟨E, (U ρU †, σ)⟩ (Sequence E) ⟨E; Prog2, (ρ, σ)⟩ → ⟨Prog2, (ρ, σ)⟩ (Stabilizer exp) ⟨c · s, σ⟩ → c · s ⟨±∫ , σ⟩ → ±σ(∫ ) , c ∈ {1, −1, i, −i} (Assignment) ⟨s u e , σ⟩ → c · s, ⟨∫ := s u e , (ρ, σ)⟩ → ⟨E, (ρ, σ[c · s/∫ ])⟩ (Sequence) ⟨Prog1, (ρ, σ)⟩ → ⟨Prog ′ 1, (ρ′, σ′)⟩ ⟨Prog1; Prog2, (ρ, σ)⟩ → ⟨Prog ′ 1; Prog2, (ρ′, σ′)⟩ (If -1) ⟨if M [∫ , ¯q] then Prog1 else Prog0 end, (ρ, σ)⟩ → ⟨Prog0, (M0ρM † 0 , σ[−σ(∫ )/∫ ])⟩ , M0 = I − ∫ 2 (If 1) ⟨if M [∫ , ¯q] then Prog1 else Prog0 end, (ρ, σ)⟩ → ⟨Prog1, (M1ρM † 1 , σ)⟩ , M1 = I + ∫ 2 (While -1) ⟨while M [∫ , ¯q] do Prog1 done, (ρ, σ)⟩ → ⟨E, (M0ρM † 0 , σ[−σ(∫ )/∫ ])⟩ (While 1) ⟨while M [∫ , ¯q] do Prog1 done, (ρ, σ)⟩ → ⟨Prog1; while M [∫ , ¯q] do Prog1 done, (M1ρM † 1 , σ)⟩ Figure 2: Operational semantics of QECV-Lang. Notations: ρq 0 = |0⟩q⟨0|ρ|0⟩q⟨0| + |0⟩q⟨1|ρ|1⟩q⟨0|. σ(∫ ) means to evaluate ∫ in state σ, while σ[s/∫ ] means to replace the evaluation of ∫ with s in the context σ. Recall that E indicates the empty program. [[skip]](ρ, σ) = (ρ, σ) [[q := |0⟩]](ρ, σ) = (ρq 0, σ) [[¯q := U [¯q]]](ρ, σ) = (U ρU †, σ) [[s]]σ = s [[±∫ ]]σ = ±σ(∫ ) [[∫ := s u e ]](ρ, σ) = (ρ, σ[[[s u e ]]σ/∫ ]) [[Prog1; Prog2]](ρ, σ) = [[Prog2]]([[Prog1]](ρ, σ)) [[if M [∫ , ¯q] then Prog1 else Prog0 end]](ρ, σ) = [[Prog1]](M1ρM † 1 , σ) + [[Prog0]](M0ρM † 0 , σ[−[[∫ ]]σ/∫ ]) [[while M [¯q] do Prog1 done]](ρ, σ) = ⊔∞ k=0[[while (k)]](ρ, σ) Figure 3: Denotational semantics of QECV-Lang. Notations: while k is the k-th unrolling of while. 6 QECV: A Veriﬁcation Framework for Quantum Error Correction Codes A PREPRINT → ⟨if M [∫0, q3q2q1q0] then skip else q0 := Xq0; ∫0 := −∫0 end, (|0001⟩⟨0001|, {∫0 = Z0123})⟩ → ⟨q0 := Xq0; ∫0 := −∫0, (|0001⟩⟨0001|, {∫0 = −Z0123})⟩ → ⟨∫0 := −∫0, (|0000⟩⟨0000|, {∫0 = −Z0123})⟩ → ⟨E, (|0000⟩⟨0000|, {∫0 = Z0123})⟩ 3.3 Denotational Semantics The denotational semantics of the QECV-Lang is given in Figure 3. The program Prog is denoted as a super-operator [[Prog]] that acts on (ρ, σ). While most rules in Figure 3 are self-explained, the while rule relies a partial order on (ρ, σ) to compute the ﬁxed point, i.e., the lowest upper bound (⊔) for the complete partial ordering (CPO) of while(k). To deﬁne the partial order on state (ρ, σ), we ﬁrst need to deﬁne a partial order on the state of stabilizers. Consider a trivial lattice on the stabilizer set S, where si ⊑ sj if si = I, and si and sj cannot be compared if they are both not identity. We can then deﬁne the partial order on σ as follows: σ1 ⊑ σ2 if σ1(∫ ) ⊑ σ2(∫ ), ∀∫ ∈ sVar, which immediately induces a partial order on (ρ, σ): (ρ1, σ1) ⊑ (ρ2, σ2) if ρ1 ⊑ ρ2 and σ1 ⊑ σ2, where ρ1 ⊑ ρ2 means that T r(Oρ1) ≤ T r(Oρ2), for any semi- positive observable O. The reason to select the partial order above is that it strictly ensures the consistency of fault-tolerant computation. If any error happens in one while loop and does not get corrected in time, the stabilizer state σ will get some variables ﬂipped. Let the resulted stabilizer state be σ′. Obviously, there does not exist any σ1 s.t. σ ⊑ σ1 and σ′ ⊑ σ1. In this case, we just set ⊔ ∞ k=0[[while(k)]](ρ, σ) to be ⊥, the bottom element of the CPO [28], which does not provide any information for the program. On the other hand, if all errors get corrected in each loop, the resulted state of while can be calculated coordinate-wisely: (⊔ ∞ k=0[[while (k)]]ρ, ⊔ ∞ k=0[[while (k)]]σ) . We connect the denotational semantics to the operational semantics through the following proposition: Proposition 3.4 (Equivalence of the denotational semantics and the operational semantics). For a strict QEC program Prog that corrects errors when the errors appear, we have [[Prog]](ρ, σ) ≡∑ {(ρ′, σ′) : ⟨Prog, (ρ, σ)⟩ → ∗ ⟨E, (ρ′, σ′)⟩}, where →∗ denotes the reﬂective, transitive closure of →, and {·} represents a multi- set. Proof. Except the while loop, other statements can be proved triv- ially by structural induction. For the while loop, the consistency can be proved with the assumption of a just-in-time error correc- tion. 4 QECV-Assn In this section, we ﬁrst introduce an expressive assertion language QECV-Assn and then derive a Hoare logic to verify QEC programs. 4.1 Syntax of QECV-Assn Stabilizer is a kind of Hermitian operator and can be used as pred- icate for QEC programs. We observe that the exponential compu- tational overhead on Hermitian-based predicates may be circum- vented by using stabilizers as predicates. In fact arithmetic oper- ations (e.g. addition and multiplication) between stabilizers can be completed within a time polynomial in the number of qubits. This observation is particularly important for QEC programs in which the majority of logical operations can be described with a few stabilizers and the corresponding predicate transformation can be framed as the multiplication of stabilizers. However, as predicates, stabilizers are not universal. There are in- ﬁnitely many quantum states that are not eigenstates of any non- identity stabilizer, e.g., |ψ⟩ = √3 2 |0⟩ + 1 2 |1⟩. Such limitation will cause difﬁculty in the veriﬁcation of QEC programs. For example, if we are given some state that is not the +1 eigenstate of any sta- bilizer (this is possible to happen in future universal fault-tolerant computation), we cannot ﬁnd any predicate except I to accommo- date such state.One well-studied way in the quantum information community to address this problem is to use the Pauli expansion of quantum Observable (Hermitian matrices) [6, 29]: Lemma 4.1 (Pauli expansion). The quantum observable O of a n-qubit system can be expressed as a linear combination of Pauli strings: O = ∑ i wiσi n, where σi n ∈ {I, X, Y, Z}⊗n is a length-n Pauli string, and wi ∈ R is its coefﬁcient. The Pauli expansion motivates the following proposition which provides a universal way to deal with arbitrary logical states in QEC programs: Proposition 4.2. ∀ |ψ⟩ ∈ Hn, there is a P which is a sum of stabi- lizers (Pauli strings), that satisﬁes P |ψ⟩ = |ψ⟩, and P ̸= I. Proof. Note that (|ψ⟩⟨ψ|)|ψ⟩ = |ψ⟩, |ψ⟩⟨ψ| is a non-identity observable and by Pauli expansion, it can be represented by a linear combination of Pauli strings, i.e., stabilizers. Inspired by Lemma 4.1 and Proposition 4.2, we introduce arith- metic expressions of stabilizers, and deﬁne the stabilizer expression se as follows, se ::= s | λ0se0 + λ1se1, λ0, λ1 ∈ C (1) where s is a stabilizer. se is different from the s u e used for stabilizer variables which only consists of unary operations on stabilizers. However, by describing both the stabilizer variable and the predi- cate within the language of stabilizer, we can easily incorporate the information from stabilizer measurement into predicates. By Proposition 4.2, se is universal as ∀|ψ⟩, ∃se s.t. se|ψ⟩ = |ψ⟩. For example, the state |ψ⟩ = √3 2 |0⟩ + 1 2 |1⟩ is a +1 eigenstate of se := 1 2 Z + √3 2 X. We then formulate the assertion language QECV-Assn on QEC programs as follows: A ::= se | A0 ∧ A1 | A0 ∨ A1 | A0 ⇒ A1. (2) When A := se, we say a QEC program state (ρ, σ) satisﬁes an assertion A if Aρ = ρ (for ρ = |ψ⟩⟨ψ|, Aρ = ρ ⇔ A|ψ⟩ = |ψ⟩) , and se is commutable with all stabilizer variables in σ. We denote this relation by (ρ, σ) |= A. Requiring se to be commutable with 7 QECV: A Veriﬁcation Framework for Quantum Error Correction Codes A PREPRINT {A}skip{A} (Skip) {A[|0⟩/q]}q := |0⟩{A} (Initialization) {A}¯q := U ¯q{U AU †} (Unitary) U is a unitary, but written in the sum of stabilizers. {A}∫ := ±∫ {A} (Assignment) {A}∫ := s{A} (Assignment) where s is commutable with A, otherwise {A}∫ := s{I}. {A}Prog1{C} {C}Prog2{B} {A}Prog1; Prog2{B} (Sequencing) {A1 ∧ ∫ }Prog1{B} {A0 ∧ −∫ }Prog0{B} {∑1 i=0 AiMi}if M [∫ , ¯q] then Prog1 else Prog0 end{B} (Condition) {A1 ∧ ∫ }Prog1{ ∑1 i=0 AiMi} {∑1 i=0 AiMi}while M [∫ , ¯q] do Prog1 end {A0 ∧ −∫ } (While) |= (A ⇒ A ′) {A ′}Prog{B′} |= (B′ ⇒ B) {A}Prog{B} (Consequence) Figure 4: Hoare rules for partial correctness assertions when A := se. stabilizer variables in σ is essential for developing the quantum Hoare logic in section 4.2. The semantics of A0 ∧ A1 and other Boolean expressions can then be derived by structural induction: • (ρ, σ) |= A1 ∧ A2 iff (ρ, σ) |= A1 and (ρ, σ) |= A2; • (ρ, σ) |= A1 ∨ A2 iff (ρ, σ) |= A1 or (ρ, σ) |= A2; • (ρ, σ) |= (A1 ⇒ A2) iff ((ρ, σ) |= A1) ⇒ ((ρ, σ) |= A2). If an assertion A is satisﬁed by any program states (ρ, σ), we sim- ply denote such property as |= A. The following lemma presents an important result for QECV-Assn that will be frequently utilized in later sections. Lemma 4.3 (Implication rule). For stabilizer expressions, 1. If (ρ, σ) |= se0 and (ρ, σ) |= se1, we have (ρ, σ) |= se0se1 and (ρ, σ) |= λ0se0 + λ1se1, where λ0 + λ1 = 1. 2. Assume se0 is not singular. If (ρ, σ) |= se0 and (ρ, σ) |= se1se0, we have (ρ, σ) |= se1. 3. Assume (ase0 + bse1)ρ = ρ, every stabilizer in σ is commutable with se0 and se1, and (ρ, σ) |= se2, then (ρ, σ) |= ase0 + bse1se2. Proof. Details are postponed to Appendix A.1. Rules from classical Boolean predicates can also be used for QECV-Assn, such as the rules for disjunction and conjunction. We will use these rules directly without extra description. Especially, the identity operator I represents True and the empty operator 0 represents False in QECV-Assn. 4.2 Partial Correctness A partial correctness assertion in QECV-Assn has the form: {A}c{B}, where A, B ∈ QECV-Assn, and c ∈ QECV-Lang. We ﬁrst present the Hoare logic for partial correctness assertions in which the precondition A is a stabilizer expression se, as shown in Figure 4. We will extend the Hoare logic to Boolean expressions like A1 ∧ A2 in Proposition 4.7. The proof rules in Figure 4 are syntax-directed and reduce proving a partial correctness assertion of a compound statement to prov- ing partial correctness assertions of its sub-statements. We only explain some rules below, since most rules are self-explained. In the initialization rule, (ρ, σ) |= A[|0⟩/q] means that Aρq 0 = ρq 0 and A commutes with all stabilizer variables in σ. This can be seen as the quantum version substitution rule. A more useful case of the initialization rule is when all qubits are reset to |0⟩, and for the n-qubit system, we have {I}qn−1 · · · q0 := |0⟩ ⊗n{Z0 ∧ Z1 ∧ · · · ∧ Zn}. (3) In the unitary rule, we represent unitary matrices as the sum of sta- bilizers in order to utilize the cheap computational cost of stabilizer multiplication. The rules for condition and while loop resembles their classical counterparts except the state may be changed by the branching condition. A direct derivative of the Condition rule is to make A1 = A0 = A as follows, Lemma 4.4. {A ∧ ∫ }Prog1{B} {A ∧ −∫ }Prog0{B} {A}if M [∫ , ¯q] then Prog1 else Prog0 end{B} . Proof. Note that M0 + M1 = I. Likewise, by letting A1 = A0 = A, we have Lemma 4.5. {A ∧ ∫ }Prog1{A} {A}while M [∫ , ¯q] do Prog1 end {A ∧ −∫ } . The consequence rule is a powerful tool for the veriﬁcation of QEC programs since it can encode facts of QEC codes into partial cor- rectness assertions. The following example demonstrates the usage of the proposed Hoare rules, including the consequence rule: Example 4.6. Assume Prog ::= ∫ := Z1; if M [∫ , q1] then skipelse q1 := Xq1; q0 := Xq0 end. We prove {Z0Z1}Prog{Z0} as follows: {Z0Z1}∫ := Z1; {Z0Z1} (Assignment) (Z0Z1)M1 = (Z0Z1) I+Z1 2 = Z0 I+Z1 2 , (Z0Z1)M0 = −Z0 I−Z1 2 {Z0Z1 ∧ Z1}skip{Z0Z1 ∧ Z1} (Skip) {Z0Z1 ∧ −Z1}q1 := Xq1{−Z0Z1 ∧ Z1} (Unitary) {−Z0Z1 ∧ Z1}q0 := Xq0{Z0Z1 ∧ Z1} (Unitary) {Z0Z1 ∧ −Z1}q1 := Xq1; q0 := Xq0{Z0Z1 ∧ Z1} (Sequencing) {Z0Z1 = (Z0Z1)M0 + (Z0Z1)M1}if M [∫ , ¯q] then skip else q1 := Xq1; q0 := Xq0 end{Z0Z1 ∧ Z1} (Condition) Then, {Z0Z1}Prog{Z0Z1 ∧ Z1} (Sequencing) Z0Z1 ∧ Z1 ⇒ Z0 (Implication) With the consequence rule, we have {Z0Z1}Prog{Z0}. Now we extend the Hoare rules in Figure 4 to other Boolean asser- tions in QECV-Assn. 8 QECV: A Veriﬁcation Framework for Quantum Error Correction Codes A PREPRINT Proposition 4.7. We restate the Hoare rules for classical Boolean assertions as follows, if {A0}Prog{B0} ∧ {A1}Prog{B1}, {A0 ∧ A1}Prog{B0 ∧ B1}; if {A0}Prog{B0} ∨ {A1}Prog{B1}, {A0 ∨ A1}Prog{B0 ∨ B1}; {I}Prog{I}, {0}Prog{B}, where B is any assertion, and 0 repre- sents an empty set of program states. For example, if se1 and se2 anti-commutes, se1 ∧ se2 = 0. Proof. Details are postponed to Appendix A.1. We prove a lemma for error correction which is frequently used in veriﬁcation sections later. Proposition 4.8 (Decoding correctness). Assume an valid error decoding and correction protocol for correct function. Let S be the set of all active stabilizer measurements in error correction, and deﬁne AS = ∧si∈Ssi, then {I}correct(∫0, ∫1, · · · ){AS}, {A ∧ AS}correct(∫0, ∫1, · · · ){A ∧ AS}, where ∫0, ∫1, · · · enumerate all elements of S. Proof. Details are postponed to Appendix A.1. Finally, we prove the soundness of Hoare rules in Figure 4. Theorem 4.9 (Soundness). The proof system in Figure 4 is sound for the partial correctness assertions. Proof. Details are postponed to Appendix A.1. 5 Theoretical Analysis In this section, we give a theoretical analysis of both the program size and the computational complexity of our framework for im- plementing and verifying surface codes [1, 30], respectively. 5.1 Program Size We ﬁrst compare the program size (i.e., the number of statements) when implementing the surface code [1, 30], in the qWhile-Lang (i.e., the quantum while-language) and the QECV-Lang (see row 2-3 of Table 2). In surface code, we consider two approaches to encode a logical qubit, the planar code and the double defect code (detailed implementation of these codes can be found in [1, 30]). For the distance-d surface code, the planar version requires O(d2) data qubits, O(d 2) parity qubits as well as O(d 2) stabilizers. The double-defect version introduces an overhead of a factor 10 in all the three quantities. As a code size estimation of QECV-Lang, we only need one state- ment per stabilizer measurement, whereas the qWhile-Lang re- quires at least eight gate operations to describe the circuit measur- ing a stabilizer [1]. Thus, QECV-Lang provides 8× program size compression for the surface code implementations. 5.2 Veriﬁcation Complexity of Clifford Gates The deﬁning property of Clifford operations is that, given a Clif- ford gate G and a stabilizer s, GsG † must also be a stabilizer, i.e. Clifford operations do not increase the number of stabilizers in the assertion. Metric Method Planar surface code Double-defect surface code Statements # qWhile-Lang O (8d 2 ) O (80d 2 ) QECV O (d 2 ) O (10d 2 ) Veriﬁcation qWhile-Lang O (8d 2 4 2 d 2 ) O (80d 2 4 20 d 2 ) Complexity QECV O (d 3 ) O (10d 3 ) Table 2: Comparison of QECV and qWhile-Lang on implementing and verifying surface codes. By framing both assertions and unitary operations in the language of stabilizers, QECV can efﬁciently processes the veriﬁcation of Clifford operations. The efﬁciency stems from the low cost of mul- tiplying stabilizers, which is O(d) because the length of the stabi- lizers for logical states is at most d for a distance-d surface code. In this way we avoid representing stabilizers as exponentially-large matrices. Therefore, QECV only incurs O(d3) computational over- head for the planar surface code and O(10d 3) computational over- head for the double-defect surface code. However, the vanilla quantum Hoare logic in qWhile-Lang can not exploit the property of Clifford operations and the low computa- tional complexity of stabilizer multiplication. The Clifford opera- tions are treated like any other unitary operations and the predicate in qWhile-Lang is a Hermitian matrix of size O(2nd+np ×2 nd+np ), where nd is the number of data qubits and np is the number of parity qubits. Hoare rules with such predicates incurs at least O(2nd+np × 2nd+np ) computational overhead. Thus, the veriﬁ- cation with qWhile-Lang requires O(8d24 2d 2) time for the planar surface code, and O(80d 2420d2) for the double-defect surface code. In summary, the proposed language design, assertion design, and the logic proof system can signiﬁcantly simplify the veriﬁcation of all Clifford operations of stabilizer codes. 5.3 Veriﬁcation Complexity of T Gate The logical T gate is usually the most challenging problem in quan- tum program veriﬁcation in general. The T gate, loosely speaking, represents a fundamental boundary between classical and quantum computing. A quantum program with T gates cannot be efﬁciently and precisely simulated or veriﬁed on a classical computer. In QECV, the number of stabilizers in our predicate will rapidly in- crease when the program to be veriﬁed has some T gates. With this being said, we argue that verifying a QEC implementa- tion of one logical T gate could be easier in many cases. The exact veriﬁcation efﬁciency would be determined by the amount of the non-Clifford operations involved in the implementation of a logi- cal T gate. In the surface code, for example, there is only one non- Clifford single-qubit physical gate [31] for a logical T gate. The veriﬁcation complexity will remain O(d 2) because the number of stabilizer terms in a predicate is still O(1). As such, QECV can still hold the exponential advantage for surface code. We remark again that such advantages come from our stabilizer-centric design in developing the veriﬁcation framework. 9 QECV: A Veriﬁcation Framework for Quantum Error Correction Codes A PREPRINT 6 Case Study I: Repetition Code In this section and the next section, we give step-by-step case study on two well-known QEC codes to guide through the usage of our framework. For each QEC code, we ﬁrst express its implemen- tation in our QECV-Lang. Then we verify the correctness of the logical operation with our proof system and show that the imple- mented QEC code can correct local errors on the physical qubits. We start from the quantum repetition code [6], which is relatively simple with light error correction overhead. This code can cor- rect bit-ﬂip error or phase-ﬂip error, but not when they happen si- multaneously. The repetition code is mainly deployed on quantum architectures whose underlying physical qubits (e.g., the cat qubit built upon bosonic quantum system [2]) already have extremely low phase-ﬂip (or bit-ﬂip) error rates. 6.1 Quantum Repetition Code We consider a three-qubit quantum repetition code to simplify the discussion. At high level, the three-qubit code just encodes one logical qubit with three physical qubits. For example, the |000⟩ state of three physical qubits represents the logical |0L⟩ state of a logical qubit, and the |111⟩ state represents the logical |1L⟩ state. We ﬁrst give the circuit diagrams for primitive operations in quan- tum repetition code and their code implementations in QECV-Lang (Figure 5). The interested reader can ﬁnd detailed explanations of the repetition code design in references [6, 7]. Figure 5 (a) (b) (c) gives the implementations of the qubit initial- ization, the logical X gate XL = X0X1X2, and the logical Z gate ZL = Z0Z1Z2, respectively. The logical CNOT gate between two logical qubits can be implemented by imposing CNOT gates on three pairs of physical qubits, as shown in Figure 5 (d). 6.2 Veriﬁcation of Logic Operations This part prove the correctness of the code segments in Figure 5 with our frameworks. It contains two major steps, deﬁning the predicates for each logical operation and constructing the proof. For the initialization operation, the expected behavior is that, for arbitrary input state, the output state should be in the logical state |0L⟩, which is the simultaneous eigenstate of the logical Z operator ZL and the stabilizers Z0Z1 and Z1Z2. Thus, we set the precon- dition to {I} and the post-condition to {ZL ∧ Z0Z1 ∧ Z1Z2}, as formulated below. Proposition 6.1 (Initialize to |0⟩). For the program Prog in Fig- ure 5(a), we have {I}Prog{ZL ∧ Z0Z1 ∧ Z1Z2}. Proof. For the initialization, {I}q0q1q2 := |000⟩{Z0 ∧ Z1 ∧ Z2}. And {Z0 ∧ Z1 ∧ Z2}∫0 := Z0Z1{Z0 ∧ Z1 ∧ Z2} and {Z0 ∧ Z1 ∧ Z2}∫1 := Z1Z2{Z0 ∧ Z1 ∧ Z2}. Since Z0 ∧ Z1 ∧ Z2 ⇒ Z0Z1 and Z0 ∧ Z1 ∧ Z2 ⇒ Z1Z2, we have Z0 ∧ Z1 ∧ Z2 ⇒ Z0 ∧ Z1 ∧ Z2 ∧ (Z0Z1) ∧ (Z1Z2). Then by Proposition 4.8, {Z0 ∧ Z1 ∧ Z2 ∧ (Z0Z1) ∧ (Z1Z2)}correct(∫0, ∫1){Z0 ∧ Z1 ∧ Z2 ∧ (Z0Z1) ∧ (Z1Z2)}. By the consequence rule, we get {I}Prog{ZL ∧ Z0Z1 ∧ Z1Z2} since Z0 ∧ Z1 ∧ Z2 ⇒ ZL. We then verify the logical X operation. It is sufﬁcient to verify two cases, the output state |1L⟩ under the input state |0⟩L, and vice versa. Arbitrary logical states can be processed as the linear com- bination of these two cases by taking advantage of the linearity of the logical X operation. Since |0⟩L corresponds to the predi- cate ZL ∧ Z0Z1 ∧ Z1Z2, and |1⟩L corresponds to the predicate −ZL ∧ Z0Z1 ∧ Z1Z2, we have the following proposition: Proposition 6.2 (Logical X gate). For the program Prog in Fig- ure 5(b), we have {ZL ∧Z0Z1 ∧Z1Z2}Prog{−ZL ∧Z0Z1 ∧Z1Z2} and {−ZL ∧ Z0Z1 ∧ Z1Z2}Prog{ZL ∧ Z0Z1 ∧ Z1Z2}. Proof. Note that X0X1X2ZLX0X1X2 = −Z1Z2Z3 = −ZL, X0X1 X2Z0Z1X0X1X2 = Z0Z1, X0X1X2Z1Z2X0X1X2 = Z1Z2. Likewise, for thel logical Z gate, we only need to verify that, the precondition {XL ∧ Z0Z1 ∧ Z1Z2} relates to the post-condition {−XL ∧ Z0Z1 ∧ Z1Z2}, and vice versa. Proposition 6.3 (Logical Z gate). For the program Prog in Fig- ure 5(c), {XL ∧ Z0Z1 ∧ Z1Z2}Prog{−XL ∧ Z0Z1 ∧ Z1Z2} and {−XL ∧ Z0Z1 ∧ Z1Z2}Prog{XL ∧ Z0Z1 ∧ Z1Z2}. Proof. Note that Z0Z1Z2XLZ0Z1Z2 = −X0X1X2 = −XL. The veriﬁcation of the logical CNOT gate involves four precon- ditions: ZL0IL1, XL0IL1, IL0XL1, and IL0ZL1, where Z0Z1 ∧ Z1Z2 ∧ Z3Z4 ∧ Z4Z5 are omitted for simplicity. These four Pauli strings are able to represent any input state by multiplica- tion and addition. The post-conditions for these four preconditions are ZL0IL1, XL0XL1, IL0XL1, and ZL0ZL1. While the ﬁrst three post-conditions are straightforward to understand, we elaborate on the fourth post-condition. The precondition IL0ZL1 speciﬁes pure states of the form (a|0⟩ + b|1⟩)L0|0⟩L1. After the CNOT gate, the state becomes a|00⟩ + b|11⟩ which is the +1 eigenstate of ZL0ZL1, for arbitrary a and b. Proposition 6.4 (Logical CNOT). For the program Prog in Figure 5(d), assume AS = Z0Z1 ∧ Z1Z2 ∧ Z3Z4 ∧ Z4Z5, we have {ZL0IL1 ∧ AS}Prog{ZL0IL1 ∧ AS}, {XL0IL1 ∧ AS}Prog{XL0XL1 ∧ AS}, {IL0XL1 ∧ AS}Prog{IL0XL1 ∧ AS}, and {IL0ZL1 ∧ AS}Prog{ ZL0ZL1 ∧ AS}. Proof. Note that for control qubit a and target qubit b, CNOTab = 1 2 (I + Xb + Za − ZaXb). Details are postponed to Appendix A.2. 6.3 Veriﬁcation on Noise Injection QECV can also reason about the correctness with hardware noise. We assume a minimum weight perfect matching error decod- ing [31] and correction as follows, Program 6.1 (Quantum repetition code error correction). For the quantum repetition code in Figure 5, deﬁne the error correction protocol as follows, for ∫0 = Z0Z1, ∫1 = Z1Z2, correct(∫0, ∫1) ::= if M [Z0Z1, q0q1] then if M [Z1Z2, q1q2] then skip else q2 := Xq2; ∫1 := −∫1 end else if M [Z1Z2, q1q2] then q0 := Xq0; ∫0 := −∫0 else q1 := Xq1; ∫0 := −∫0; ∫1 := −∫1 end end 10 QECV: A Veriﬁcation Framework for Quantum Error Correction Codes A PREPRINT q2q1q0 := |000⟩ ∫0 := Z0Z1 ∫1 := Z1Z2 correct(∫0, ∫1) (a) Initialization. ∫0 := I ∫1 := I q2q1q0 := X2X1X0q2q1q0 ∫0 := Z0Z1 ∫1 := Z1Z2 (b) Logical X gate. ∫0 := I ∫1 := I q2q1q0 := Z2Z1Z0q2q1q0 ∫0 := Z0Z1 ∫1 := Z1Z2 (c) Logical Z gate. ∫0 := I; ∫1 := I; ∫2 := I; ∫3 := I; q0q3 := CXq0q3; q1q4 := CXq1q4; q2q5 := CXq2q5; ∫0 := Z0Z1; ∫1 := Z1Z2 ∫2 := Z3Z4; ∫3 := Z4Z5 (d) Logical CX gate. Figure 5: Circuit diagrams for primitive operations in quantum repetition code and their code implementations in QECV-Lang. s1, s2, s3, s4 are parity qubits. q0, q1, q2, q3, q4, q5 are data qubits. ∫0 := I ∫1 := I q2q1q0 := X2X1X0q2q1q0 // an X error on q1; q1 := X1q1 ∫0 := Z0Z1 ∫1 := Z1Z2 correct(∫0, ∫1); (a) An X error on q1 ∫0 := I ∫1 := I q2q1q0 := X2X1X0q2q1q0 // an Z error on q1; q1 := Z1q1; ∫0 := Z0Z1 ∫1 := Z1Z2 correct(∫0, ∫1); (b) A Z error on q1 Figure 6: Two noisy logical X gates. In Figure 6(a), we present a noisy logical X gate where an X error occurs on q1. We prove that the expected behavior of the noisy logical X gate is the same as that of the error-free logical X gate with the help of error correction. Proposition 6.5. For the program Prog in Figure 6(a), which im- plements a noisy logical X gate, {ZL ∧ Z0Z1 ∧ Z1Z2}Prog{−ZL ∧ Z0Z1 ∧ Z1Z2}, and {−ZL ∧ Z0Z1 ∧ Z1Z2}Prog{ZL ∧ Z0Z1 ∧ Z1Z2}. Proof. We only prove {ZL ∧ Z0Z1 ∧ Z1Z2}Prog{−ZL ∧ Z0Z1 ∧ Z1Z2} for simplicity. ZL ∧ Z0Z1 ∧ Z1Z2 ⇒ Z0 ∧ Z1 ∧ Z2; {Z0 ∧ Z1 ∧ Z2}∫0 := I{Z0 ∧ Z1 ∧ Z2}; {Z0 ∧ Z1 ∧ Z2}∫1 := I{Z0 ∧ Z1 ∧ Z2}; {Z0 ∧ Z1 ∧ Z2}q2q1q0 := X2X1X0q2q1q0{−Z0 ∧ −Z1 ∧ −Z2}; {−Z0 ∧ −Z1 ∧ −Z2}q1 := X1q1{−Z0 ∧ Z1 ∧ −Z2}; {−Z0 ∧ Z1 ∧ −Z2}∫0 := Z0Z1{−Z0 ∧ Z1 ∧ −Z2}; {−Z0 ∧ Z1 ∧ −Z2}∫1 := Z1Z2{−Z0 ∧ Z1 ∧ −Z2}; For the correct statement, −Z0 ∧ Z1 ∧ −Z2 ∧ Z0Z1 = 0, −Z0 ∧ Z1 ∧ −Z2 ∧ Z1Z2 = 0, and {−Z0 ∧ Z1 ∧ −Z2 ∧ −Z0Z1 ∧ −Z1Z2}q1 := Xq1; ∫0 := −∫0; ∫1 := −∫1{−Z0 ∧ −Z1 ∧ −Z2 ∧ Z0Z1 ∧ Z1Z2}, so {−Z0 ∧Z1 ∧−Z2}correct(∫0, ∫1){−Z0 ∧−Z1 ∧−Z2 ∧Z0Z1 ∧ Z1Z2}. Then by the consequence rule, we get {ZL ∧ Z0Z1 ∧ Z1Z2}Prog{−ZL ∧ Z0Z1 ∧ Z1Z2}. However, the error correction protocol in Program 6.1 can not cor- rect Z errors, as shown in the following proposition, Proposition 6.6. For the program Prog in Figure 6(b), where a Z error happens on q1, we have {XL ∧ Z0Z1 ∧ Z1Z2}Prog{−XL ∧ Z0Z1 ∧ Z1Z2} and {−XL ∧ Z0Z1 ∧ Z1Z2}Prog{XL ∧ Z0Z1 ∧ Z1Z2}, which is not the desired behaviour of the logical X gate. Proof. Similar to the proof in Proposition 6.5. 7 Case Study II: Surface Code In this section, we present the veriﬁcation of the double-defect sur- face code [1]. There are two types of stabilizers in surface code, of which one is called ‘Z-type’ stabilizer as it only consists of Pauli Z operators and the other one is called ‘X-type’ stabilizer as it only contains Pauli X operators. These two types of stabilizers together enable high error tolerance of surface code as well as the ability to correct both bit-ﬂip error and phase-ﬂip error simultaneously. Im- plementing surface code has been pursued by several major quan- tum computing vendors including IBM [3] and Google [32]. 7.1 Surface Code Double-defect surface code includes a series of logical operations to support fault-tolerant quantum computation, such as initial- ization, measurement, defect enlarging, defect shrinking, logical single-qubit gates (X, Z, H), qubit moving, braiding and the logi- cal CNOT gate. In this section, we only verify qubit initialization, qubit moving, logical Pauli gates and logical qubit braiding. The veriﬁcation of remaining operations is similar to or can be built upon the veriﬁed operations. For example, qubit measurement is the reversing process of qubit initialization, and the logical CNOT gate is the concatenation of three braiding operations. Without loss of generality, we only consider the distance-3 surface code. The logical operations shown in Figure 7 is implemented in QECV-Lang in Figure 8. We mainly focus on the operations on the X-cut qubit, which is a kind of logical qubit created by dis- abling X-type stabilizers. We present the initialization operation in Figure 7(a) which initializes a X-cut qubit to the logical state |+L⟩, i.e., the +1 eigenstate of the logical X operator XL in Figure 7. Fig- ure 7(b) shows the logical Z gate ZL. We then implements the qubit moving operation and the loigcal H gate shown in Figure 7(c)(d). 11 QECV: A Veriﬁcation Framework for Quantum Error Correction Codes A PREPRINT The qubit moving operation will not change the logical state. For the logical H gate, we only presents a simpliﬁed version which is enough to demonstrate the core idea of the logical H gate in [1]. Finally, we include the veriﬁcation of qubit initialization (to |0L⟩), the logical X gate and the braiding operation in Appendix A.3. All proofs in this section will be postponed to Appendix A.3. 7.2 Veriﬁcation of Logic Operations As speciﬁed by the surface code [1], any valid logical state should always be in the +1 eigenspace of all active stabilizers on the surface code array, S = {s0, s1, · · · }. For simpliﬁca- tion, we omit the stabilizers that does not involve in proof. For example, (|0L⟩⟨0L|, σ) |= ZL ∧ s0 ∧ s1 · · · will be denoted by (|0L⟩⟨0L|, σ) |= ZL. In the cases where we need to stress other ac- tive stabilizers in the array, we will have (|0L⟩⟨0L|, σ) |= ZL ∧AS, where AS = ∧s∈Ss. We ﬁrst verify the initialization to |+L⟩. The expected functional- ity of the initialization operation is to prepare arbitrary state into a desired state, as shown in the following proposition. The precondi- tion of the partial correctness is just I which allows any state. As for the post-condition, notice that |+L⟩ is stabilized by the stabi- lizer X0X1X2X4 (i.e., XL) and other active stabilizers in S. The veriﬁcation of initialization to |0L⟩ is similar and postponed to Ap- pendix A.3. Proposition 7.1 (Initialize |+⟩L). For the program Prog in Fig- ure 8(a) which initializes a X-cut logical qubit to |+⟩L, as shown in Figure 7(a), we have {I}Prog{X0X1X2X4 ∧ AS}. The veriﬁcation of the logical Z gate is similar to that in quantum repetition code and the precondition and post-condition can be de- rived in a similar way. The veriﬁcation of logical X gate is similar and postponed to Appendix A.3. Proposition 7.2 (Logical Z gate). For program Prog in Figure 8(b) which implements the logical Z gate in Figure 7(b), we have {XL}Prog{−XL} and {−XL}Prog{XL}, where XL = X0X1X2X4. To reason about qubit moving, the key is to prove that the logical state is preserved. We ﬁrst represent the current state of data qubits with the stabilizer language. The following lemma shows that there is a one-to-one mapping between the stabilizer expressions and the logical quantum states. Lemma 7.3. For a X-cut qubit state |ψ⟩, if |ψ⟩ = α|0⟩L + β|1⟩L (|α| 2 + |β| 2 = 1), then there is a unique (aZL + bXL) s.t. (aZL + bXL)|ψ⟩ = |ψ⟩, and in this case a = α2−β2 α2+β2 and b = 2αβ α2+β2 . Conversely, for a X-cut qubit state |ψ⟩, if ( α 2−β2 α2+β2 ZL + 2αβ α2+β2 XL) ∗ |ψ⟩ = |ψ⟩, and |ψ⟩ is in the space spanned by {|0L⟩, |1L⟩}, then |ψ⟩ = α|0⟩L + β|1⟩L, up to a global phase. We then apply Lemma 7.3 to verify the vertical qubit moving oper- ation in Figure 7(c). The veriﬁcation of the horizontal qubit moving is similar. The following proposition conﬁrms that the logical state is not changed since the precondition and the post-condition have equal coefﬁcients w.r.t. the logical X and logical Z operators. Proposition 7.4 (Vertical qubit moving). For program Prog in Figure 8(c) which implements the qubit moving operation in Fig- ure 7(c) , we have {aZL + bXL}Prog{aZ ′ L + bX ′ L}, where ZL = Z0Z1Z2, XL = X2X3X4X6, Z ′ L = Z0Z1Z2Z6, X ′ L = X6X8X9X10, a, b ∈ C. While the implementation of the logical H gate requires isolating the defects of a logical qubit, the core of logical H operation is to perform local H gates for the area outlined in Figure 7(d), which alone is a distance-3 planar surface code. We will only verify that part of program for simplicity. Other parts of the logical H oper- ation can be veriﬁed on top of veriﬁed operations above. Like in the case in quantum repetition code, we only need to verify that the logical X operator is transformed into the logical Z operator and the logical Z operator is transformed into the logical X operator. Proposition 7.5 (Logical H gate). For the program Prog in Fig- ure 8(d) which implements the simpliﬁed logical H gate in Fig- ure 7(d) , we have {ZL}Prog{X ′ L}, {XL}Prog{Z ′ L}, where ZL = Z1Z6Z11, XL = X5X6X7, Z ′ L = Z5Z6Z7, X ′ L = X1X6X11 for the distance-3 planar surface code outlined in Figure 7(d). 7.3 Veriﬁcation on Noise Injection To reason the correctness when noise exists, we assume a minimal weight perfect matching (MWPM) decoder [31] and error correc- tion for the surface code array. When the error only happens on one qubit, it can be easily detected by the decoder and be corrected, as indicated below: Proposition 7.6. For the program Prog in Figure 9(a) which im- plements a noisy version of the logical Z gate in Figure 7(b), {XL ∧ AS}Prog{−XL ∧ AS}, {−XL ∧ AS}Prog{XL ∧ AS}, where XL = X0X1X2X4. When we increase the Z error location by one, the error correction protocol may fail. Proposition 7.7. For the program Prog in Figure 9(b), {XL ∧ AS}Prog{XL ∧ AS}, {−XL ∧ AS}Prog{−XL ∧ AS}, which is not the desired behavior of the logical Z gate. The proposition 7.7 is expected because a distance-d surface code cannot correct errors on more than ⌊ d 2 ⌋ qubits. More complicated cases can be proved in a similar way with our veriﬁcation frame- work. 8 Conclusion Quantum error correction is the bedrock of fault-tolerant quantum computation, and its veriﬁcation is of signiﬁcant importance for the forthcoming large-scale quantum computing. In this paper, we propose QECV, an efﬁcient veriﬁcation framework for stabilizer codes. QECV ﬁrst comes with a concise language, QECV-Lang, which incorporates stabilizers to represent QEC programs. Stabi- lizers together with stabilizer expressions are also used as predi- cates in our new assertion language, QECV-Assn. We then derive a sound quantum Hoare logic to efﬁciently reason about the correct- ness of QEC programs. Finally, We evaluate QECV by a theoretical complexity analysis and case studies on two QEC codes. We be- lieve this work will spark more interest in the veriﬁcation of QEC programs which may become a prevalent programming paradigm in the near future. 12 QECV: A Veriﬁcation Framework for Quantum Error Correction Codes A PREPRINT (a) Initializes |+L⟩ (b) logical Z gate ZL (c) Vertical qubit moving (d) Logical H gate Figure 7: Primitive operations in the double-defect surface code . X stabilizers are yellow, and Z stabilizers are blue. // reset qubit array; ¯q := |0⟩ // enable all stabilizers; ∫0 := X0X1X2X4 ∫1 := X13X14X15X16 · · · // establish state; correct(∫0, ∫1, · · · ) // turn off 2 stabilizers; ∫0 := I; ∫1 := I (a) Initialization of |+L⟩ ¯q := Z4Z9Z13 ¯q (b) Logical Z gate ∫0 := I; ∫1 := X6X8X9X10; ∫2 := Z3Z5Z6Z8; ∫3 := Z4Z6Z7Z9; ∫4 · · · correct(∫0, ∫1 · · · ) ∫1 := I; ∫2 := Z3Z5Z8; ∫3 := Z4Z7Z9; ∫w+1 := Z6; if M [∫w+1, ¯q] then −skip else −¯q := X6X8X9X10 ¯q; −∫w+1 := Z6 end ∫0 := X2X3X4X6; ∫2 := Z3Z5Z6Z8; ∫3 := Z4Z6Z7Z9; correct(∫0, ∫1 · · · ) (c) Vertical qubit moving. // turn off all local stabilizers, // and stop error detection; ∫0 := I; ∫1 := I; ∫2 · · · //perform local H gates ¯q := H ¯q // turn on all local stabilizers; // switch stabilizer type; ∫0 := X3X5X6X8; ∫1 := Z1Z3Z4Z6; ∫2 · · · (d) Logical H gate by local H gates Figure 8: Implementation of primitive operations of the double-defect surface code in QECV-Lang. 13 QECV: A Veriﬁcation Framework for Quantum Error Correction Codes A PREPRINT q4q9q13 := Z4Z9Z13q4q9q13 // an Z error on qubit q9; q9 := Z9q9 // assume ∫0, ∫1, · · · // be the active stabilizers; correct(∫0, ∫1, · · · ) (a) a Z error on q9. q4q9q13 := Z4Z9Z13q4q9q13 // Z errors on qubit q9, q13 q9 := Z9q9; q13 := Z13q13; correct(∫0, ∫1, · · · ) (b) two Z errors on q9, q13. Figure 9: Noisy programs of the logical Z gate in Figure 7(b). References [1] Austin G. Fowler, Matteo Mariantoni, John M. Martinis, and Andrew N Cleland. Surface codes: Towards practical large- scale quantum computation. Physical Review A, 86:032324, 2012. [2] Christopher Chamberland, Kyungjoo Noh, Patricio Arrangoiz-Arriola, Earl T. Campbell, Connor T. Hann, Joseph Iverson, Harald Putterman, Thomas C. Bohdanowicz, Steven T. Flammia, Andrew J. Keller, Gil Refael, John Preskill, Liang Jiang, Amir H. Safavi-Naeini, Oskar J. Painter, and Fernando G. S. L. Brand˜ao. Building a fault- tolerant quantum computer using concatenated cat codes. arXiv: Quantum Physics, 2020. [3] Christopher Chamberland, Guanyu Zhu, Theodore J. Yoder, Jared B. Hertzberg, and Andrew W. Cross. Topological and subsystem codes on low-degree graphs with ﬂag qubits. Phys- ical Review X, 10, 2020. [4] John Preskill. Quantum computing in the nisq era and be- yond. Quantum, 2018. [5] Adam Holmes, Mohammad Reza Jokar, Ghasem Pasandi, Yongshan Ding, Massoud Pedram, and Frederic T. Chong. Nisq+: Boosting quantum computing power by approximat- ing quantum error correction. 2020 ACM/IEEE 47th Annual International Symposium on Computer Architecture (ISCA), pages 556–569, 2020. [6] Michael A Nielsen and Isaac Chuang. Quantum computation and quantum information, 2002. [7] Adam Jozef Zalcman, Alan Derk, Alan Ho, Alex Opremcak, Alexander Korotkov, Alexandre Bourassa, Andre Gregory Petukhov, Andreas Bengtsson, Andrew Dunsworth, Anthony Megrant, Austin Fowler, B´alint Pat´o, Benjamin Chiaro, Ben- jamin Villalonga, Brian Burkett, Brooks Riley Foxen, Cather- ine Erickson, Charles Neill, Chris Quintana, Cody Jones, Craig Michael Gidney, Daniel Eppens, Daniel Sank, Dave Landhuis, David A Buell, Doug Strain, Dvir Kafri, Edward Farhi, Eric Ostby, Erik Lucero, Evan Jeffrey, Fedor Kostritsa, Frank Carlton Arute, Hartmut Neven, Igor Aleiner, Jamie Yao, Jarrod Ryan McClean, Jeremy Patterson Hilton, Jimmy Chen, Jonathan Arthur Gross, Joseph Bardin, Josh Mutus, Juan Atalaya, Julian Kelly, Kevin Miao, Kevin Satzinger, Kostyantyn Kechedzhi, Kunal Arya, Marco Szalay, Marissa Giustina, Masoud Mohseni, Matt McEwen, Matt Trevithick, Matthew Neeley, Matthew P Harrigan, Michael Broughton, Michael Newman, Murphy Yuezhen Niu, Nicholas Bush- nell, Nicholas Redd, Nicholas Rubin, Ofer Naaman, Orion Martin, Paul Victor Klimov, Pavel Laptev, Pedram Roushan, Ping Yeh, Rami Barends, Roberto Collins, Ryan Babbush, Sabrina Hong, Sean Demura, Sean Harrington, Seon Kim, Sergei Isakov, Sergio Boixo, Ted White, Thomas E O’Brien, Trent Huang, Trevor Mccourt, Vadim Smelyanskiy, Vladimir Shvarts, William Courtney, Wojtek Mruczkiewicz, Xiao Mi, Yu Chen, and Zhang Jiang. Exponential suppression of bit or phase ﬂip errors with repetitive quantum error correction. Nature, 2021. [8] Christopher Chamberland, Guanyu Zhu, Theodore J. Yoder, Jared B. Hertzberg, and Andrew W. Cross. Topological and subsystem codes on low-degree graphs with ﬂag qubits. Phys. Rev. X, 10:011022, Jan 2020. [9] Daniel Gottesman. Stabilizer codes and quantum error cor- rection. arXiv: Quantum Physics, 1997. [10] Lingling Lao and Carmen Garcia Almudever. Fault-tolerant quantum error correction on near-term quantum processors using ﬂag and bridge qubits. Physical Review A, 101:032333, 2020. [11] Rui Chao and Ben Reichardt. Flag fault-tolerant error correc- tion for any stabilizer code. arXiv: Quantum Physics, 2019. [12] Kyungjoo Noh and Christopher Chamberland. Fault- tolerant bosonic quantum error correction with the surface–gottesman-kitaev-preskill code. Physical Review A, 101:012316, 2020. [13] Xin-Chuan Wu, Sheng Di, Emma Maitreyee Dasgupta, Franck Cappello, Hal Finkel, Yuri Alexeev, and Frederic T. Chong. Full-state quantum circuit simulation by using data compression. Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis, 2019. [14] Li Zhou, Nengkun Yu, and Mingsheng Ying. An applied quantum hoare logic. Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and Imple- mentation, 2019. [15] Gushu Li, Li Zhou, Nengkun Yu, Yufei Ding, Mingsheng Ying, and Yuan Xie. Projection-based runtime assertions for testing and debugging quantum programs. Proceedings of the ACM on Programming Languages, 4:1 – 29, 2020. [16] Mingsheng Ying. Floyd–hoare logic for quantum programs. ACM Trans. Program. Lang. Syst., 33:19:1–19:49, 2012. [17] Mingsheng Ying and Yangjia Li. Reasoning about parallel quantum programs. ArXiv, abs/1810.11334, 2018. [18] Dominique Unruh. Quantum hoare logic with ghost variables. 2019 34th Annual ACM/IEEE Symposium on Logic in Com- puter Science (LICS), pages 1–13, 2019. [19] Ellie D’Hondt and P. Panangaden. Quantum weakest pre- conditions. Mathematical Structures in Computer Science, 16:429 – 451, 2006. [20] Peter Selinger. Towards a quantum programming language. Mathematical Structures in Computer Science, 14:527 – 586, 2004. [21] Yuan Feng and Mingsheng Ying. Quantum hoare logic with classical variables. ArXiv, abs/2008.06812, 2020. 14 QECV: A Veriﬁcation Framework for Quantum Error Correction Codes A PREPRINT [22] Yuan Feng, Sanjiang Li, and Mingsheng Ying. Veriﬁcation of distributed quantum programs. ArXiv, abs/2104.14796, 2021. [23] Nengkun Yu and Jens Palsberg. Quantum abstract interpreta- tion. Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and Imple- mentation, 2021. [24] Robert Rand, Aarthi Sundaram, Kartik Singhal, and Brad Lackey. Static analysis of quantum programs via gottesman types. ArXiv, abs/2101.08939, 2021. [25] Robert Rand, Kartik Singhal, Brad Lackey, and Microsoft. Extending gottesman types beyond the clifford group. In arXiv, 2021. [26] Robert Rand, Aarthi Sundaram, Kartik Singhal, and Brad Lackey. Gottesman types for quantum programs. ArXiv, abs/2109.02197, 2021. [27] Garrett Birkhoff and John von Neumann. The logic of quan- tum mechanics. Annals of Mathematics, 37:1–26, 1936. [28] Glynn Winskel. The formal semantics of programming lan- guages - an introduction. In Foundation of computing series, 1993. [29] Mark M. Wilde. Quantum information theory. In Quantum Information Theory, 2013. [30] Clare Horsman, Austin G. Fowler, Simon J. Devitt, and Rod- ney Van Meter. Surface code quantum computing by lattice surgery. New Journal of Physics, 14:123011, 2012. [31] Austin G. Fowler. Minimum weight perfect matching of fault- tolerant topological quantum error correction in average o(1) parallel time. Quantum Inf. Comput., 15:145–158, 2015. [32] Zijun Kevin J. Juan Alexander N. Andrew Daniel Chris Mat Chen Satzinger Atalaya Korotkov Dunsworth Sank Qui, Zijun Chen, Kevin J Satzinger, Juan Atalaya, Alexan- der N. Korotkov, Andrew Dunsworth, Daniel Thomas Sank, Chris Quintana, Matthew J. McEwen, Rami Barends, Paul Klimov, Sabrina Hong, Cody Jones, Andre Petukhov, Dvir Kafri, Sean Demura, Brian Burkett, Craig Gidney, Austin G. Fowler, Alexandru Paler, Harald Putterman, Igor L. Aleiner, Frank Arute, Kunal Arya, Ryan Babbush, Joseph C. Bardin, Andreas Bengtsson, Alexandre Bourassa, Mick Broughton, Bob B. Buckley, David A. Buell, Nicholas Bush- nell, Benjamin Chiaro, Roberto Collins, William Court- ney, Alan R. Derk, Daniel Eppens, Catherine Erickson, Ed- ward Farhi, Brooks Foxen, Marissa Giustina, Ami Greene, Jonathan A. Gross, Matthew P. Harrigan, Sean D. Harring- ton, Jeremy P. Hilton, Alan Ho, Trent Huang, William J. Huggins, L B Ioffe, Sergei V. Isakov, Evan Jeffrey, Zhang Jiang, Kostyantyn Kechedzhi, Seon Kim, Alexei Y. Kitaev, Fedor Kostritsa, David Landhuis, Pavel Laptev, Erik Lucero, Orion Martin, Jarrod R. McClean, Trevor McCourt, Xiao Mi, Kevin C. Miao, Masoud Mohseni, Shirin Montazeri, Wo- jciech Mruczkiewicz, Josh Mutus, Ofer Naaman, Matthew Neeley, Charles J. Neill, Michael Newman, Murphy Yuezhen Niu, Thomas E. O’Brien, Alexander Opremcak, Eric P. Ostby, B´alint Pat´o, N Redd, Pedram Roushan, Nicholas C Rubin, Vladimir Shvarts, Doug Strain, Marco Szalay, Matthew D Trevithick, Benjamin Villalonga, Theodore White, Z. Jamie Yao, P Yeh, Juhwan Yoo, Adam Zalcman, Hartmut Neven, Sergio Boixo, Vadim N. Smelyanskiy, Yu Chen, Anthony Megrant, and Julian Kelly. Exponential suppression of bit or phase errors with cyclic error correction. Nature, 595:383 – 387, 2021. 15 QECV: A Veriﬁcation Framework for Quantum Error Correction Codes A PREPRINT A Appendix A.1 Proof in QECV-Assn Lemma 4.3 (Implication rule). For stabilizer expressions, 1. If (ρ, σ) |= se0 and (ρ, σ) |= se1, we have (ρ, σ) |= se0se1 and (ρ, σ) |= λ0se0 + λ1se1, where λ0 + λ1 = 1. 2. Assume se0 is not singular. If (ρ, σ) |= se0 and (ρ, σ) |= se1se0, we have (ρ, σ) |= se1. 3. Assume (ase0 + bse1)ρ = ρ, every stabilizer in σ is commutable with se0 and se1, and (ρ, σ) |= se2, then (ρ, σ) |= ase0 + bse1se2. Proof. For the ﬁrst rule, note that (se0se1)ρ = se0(se1ρ) = se0ρ = ρ. Also, ∀∫ ∈ σ, se0se1∫ = se0∫ se1 = ∫ se0se1. Thus, (ρ, σ) |= se0se1. (ρ, σ) |= λ0se0 + λ1se1 can be proved similarly. For the second rule, note that se1ρ = se1(se0ρ) = (se1se0)ρ = ρ, and ∀∫ ∈ σ, (∫ se1)se0 = se1 se0∫ = (se1∫ )se0. Since se0 is not singular, we have ∫ se1 = se1 ∫ , thus (ρ, σ) |= se1. For the ﬁnal rule, notice that (ase0 + bse1se2)ρ = ase0ρ + bse1se2ρ = ase0ρ + bse1ρ = ρ. Finally, it is easy to see in all these rules, the stabilizer in σ is commutable with the target stabilizer expressions. Proposition 4.7. We restate the Hoare rules for classical Boolean assertions as follows, if {A0}Prog{B0} ∧ {A1}Prog{B1}, {A0 ∧ A1}Prog{B0 ∧ B1}; if {A0}Prog{B0} ∨ {A1}Prog{B1}, {A0 ∨ A1}Prog{B0 ∨ B1}; {I}Prog{I}, {0}Prog{B}, where B is any assertion, and 0 represents an empty set of program states. For example, if se1 and se2 anti-commutes, se1 ∧ se2 = 0. Proof. We ﬁrst prove the conjunction rule. Since A0 ∧ A1 ⇒ A0, A0 ∧ A1 ⇒ A1, then by the consequence rule, we have {A0 ∧ A1}Prog{B0} and {A0 ∧ A1}Prog{B1}, i.e., {A0 ∧ A1}Prog{B0 ∧ B1}. For the disjunction rule, notice that if (ρ, σ) |= (A0 ∨ A1), then either (ρ, σ) |= A0 or (ρ, σ) |= A1. Finally, {I}Prog{I} always holds since any state (ρ, σ) satisﬁes I. {0}Prog{B} is true because (ρ, σ) |= 0 ⇒ [[P ]](ρ, σ) |= B. Proposition 4.8 (Decoding correctness). Assume an valid error decoding and correction protocol for correct function. Let S be the set of all active stabilizer measurements in error correction, and deﬁne AS = ∧si∈Ssi, then {I}correct(∫0, ∫1, · · · ){AS}, {A ∧ AS}correct(∫0, ∫1, · · · ){A ∧ AS}, where ∫0, ∫1, · · · enumerate all elements of S. Proof. First, any valid correction function will project the state into one quiescent state of the QEC code. It’s the deﬁnition of QEC code error correction. Second, note that the assertion A ∧ AS represents error-free states in the QEC code, thus any valid correct protocol will place a skip statement for correcting the error-free state. Assume the correct protocol is implemented based on the look-up table, since A ∧ AS ∧ −∫i = 0, then by the condition rule and {0}Prog{A ∧ AS} (Lemma 4.7), we directly get {A ∧ AS}correct(∫0, ∫1, · · · ){A ∧ AS}. Theorem 4.9 (Soundness). The proof system in Figure 4 is sound for the partial correctness assertions. Proof. (1) Skip. Note than the skip rule does not change the program state. (2) Initialization. By the deﬁnition of the substitution rule, (ρ, σ) |= A[|0⟩/ρ] is equivalent to (ρq 0, σ) |= A, then the state after initialization (ρ′, σ) = (ρq 0, σ) also satisﬁes A. (3) Unitary. Note that (U AU †)(U ρU †) = U AρU †, so (U AU †)(U ρU †) = (U ρU †) ⇔ Aρ = ρ. (4) Assignment. For the ﬁrst rule, assume (ρ, σ) |= A, then A is commutable with ∫ . Then, A is also commutable with −∫ . Thus, (ρ, σ′) = (ρ, σ[−∫ /∫ ]) also satisﬁes A. The second rule is obviously correct, but it limits the selection of A. (5) Sequencing. Assume (ρ, σ) |= A, then [[P0]](ρ, σ) |= C by the hypothesis {A}P0{C}. On the other hand [[P0; P1]](ρ, σ) = [[P1]]([[P0]](ρ, σ)) |= B by the hypothesis {C}P1{B}. (6) Condition. First, ∑ AiMi is a legal stabilizer expression because M1 = I+∫ 2 and M0 = I−∫ 2 are legal stabilizer expressions. Assume (ρ, σ) |= A, then σ(∫ ) is commutable with A, so is M1 and M0. Thus, AM1ρM † 1 = M1AρM † 1 = M1ρM † 1 . Likewise, we have AM0ρM † 0 = M0ρM † 0 . Let A = ∑ i AiMi, then AM1ρM † 1 = A1M1(M1ρM † 1 ) + A0M0(M1ρM † 1 ) = A1(M1ρM † 1 ) since M1M1 = M1, M1M0 = 0. Thus, we have A1M1ρM † 1 = M1ρM † 1 . Since ∫ is commutable with both A1 and A0, we have (M1ρM † 1 , σ) |= A1 16 QECV: A Veriﬁcation Framework for Quantum Error Correction Codes A PREPRINT and (M0ρM † 0 , σ[−∫ /∫ ]) |= A0. Also, (M1ρM † 1 , σ) |= ∫ and (M0ρM † 0 , σ[−∫ /∫ ]) |= −∫ . Thus, if (ρ, σ) |= ∑i AiMi, we have (M1ρM † 1 , σ) |= A1 ∧ ∫ and (M0ρM † 0 , σ) |= A0 ∧ −∫ . Since {A1 ∧ ∫ }P1{B} and {A0 ∧ −∫ }P0{B}, by the semantics of the condition statement, we have { ∑ AiMi}if M [∫ , ¯q] then P0 else P1 end{B}. (7) While. The proof of the While rule is quite similar to that of the Condition rule. ∑ AiMi is called the invariant of the loop. If the execution enters the loop body, then by {A1 ∧ ∫ }P0{∑ AiMi}, we still have (ρ, σ) |= ∑ AiMi for the next loop. So, when the while loop terminates, we always have (ρ, σ) |= A0 ∧ −∫ . To prove the While rule more formally, we only need to show the partial correctness holds for while(k), as while is the disjunction of while(k), k = 0, 1, 2, · · · . (8) Consequence. Assume (ρ, σ) |= A, then (ρ, σ) |= A′ by {A ⇒ A′}. Since {A′}Prog{B′}, we have [[P ]](ρ, σ) |= B′. Then [[P ]](ρ, σ) |= B by B′ ⇒ B. Thus, {A}Prog{B}. A.2 Veriﬁcation of Quantum Repetition Code Proposition 6.4 (Logical CNOT). For the program Prog in Figure 5(d), assume AS = Z0Z1 ∧ Z1Z2 ∧ Z3Z4 ∧ Z4Z5, we have {ZL0IL1 ∧ AS}Prog{ZL0IL1 ∧ AS}, {XL0IL1 ∧ AS}Prog{XL0XL1 ∧ AS}, {IL0XL1 ∧ AS}Prog{IL0XL1 ∧ AS}, and {IL0ZL1 ∧ AS}Prog{ ZL0ZL1 ∧ AS}. Proof. First, for control qubit a and target qubit b, CNOTab = 1 2 (I + Xb + Za − ZaXb). Then (1) {ZL0IL1}Prog{ZL0IL1}. Note that both CNOT03, CNOT14 and CNOT25 are commutable with ZL0, so CNOT03ZL0CNOT03 = ZL0CNOT03CNOT03 = ZL0, , CNOT14ZL0CNOT14 = ZL0 and CNOT25ZL0CNOT25 = ZL0. (2) {XL0IL1}Prog{XL0XL1}. Note that CNOT 03XL0CNOT03 = XL0X3. Since X3 is commutable with CNOT14, CNOT14XL0X3CNOT14 = (CNOT 14XL0CNOT14)X3 = XL0X4X3. Finally, CNOT25XL0X4X3CNOT25 = XL0X5X4X3 = XL0XL1. (3) {IL0XL1}Prog{IL0XL1}. Note that both CNOT03, CNOT14 and CNOT25 are commutable with XL1. (4) {IL0ZL1}Prog{ZL0ZL1}. Note that CNOT03ZL1CNOT03 = Z0ZL1, CNOT14Z0ZL1CNOT14 = Z0CNOT14ZL1CNOT14 = Z0Z1ZL1, and CNOT25Z0Z1ZL1CNOT25 = Z0Z1CNOT25ZL1CNOT25 = Z0Z1Z2ZL1 = ZL0ZL1. Finally, We can prove that {Z0Z1}Prog{Z0Z1}, {Z1Z2}Prog{Z1Z2}, {Z3Z4}Prog{Z0Z1Z3Z4}, {Z4Z5}Prog{Z1Z2Z4Z5} in a sim- ilar way. Combing all these facts, we can prove the desired partial correctness on the logical CNOT gate. A.3 Veriﬁcation of the Surface Code Program A.1 (Initialize |0L⟩). For the initialization operation in the ﬁgure below, which initializes an X-cut logical qubit to |0L⟩, we have Prog ::= ¯q := |0⟩; ∫0 := X0X1X2X4; ∫1 := X4X6X7X9; ∫2 := X9X11X12X14; ∫3 := X14X16X17X18; ∫4 := Z1Z3Z4Z6; ∫5 := Z2Z4Z5Z7; ∫6 := Z6Z8Z9Z11; ∫7 := Z11Z13Z14Z16; ∫8 := Z7Z9Z10Z12; ∫9 := Z12Z14Z15Z17; ∫10 := · · · correct(∫0, ∫1, · · · ); ∫0 := I; ∫1 := I; ∫2 := I; ∫3 := I; ∫4 := Z1Z3Z6; ∫5 := Z2Z5Z7; ∫6 := Z6Z8Z11; ∫7 := Z11Z13Z16; ∫8 := Z7Z10Z12; ∫9 := Z12Z15Z17; ∫10 := · · · ∫w+1 := Z4; ∫w+2 := Z9; ∫w+3 := Z14; // set q4, q9, q14 to |0⟩; if M [∫w+1, q4] then skip else ¯q := X4X6X7X9 ¯q; ∫w+1 := Z4 end if M [∫w+2, q9] then−skip else−¯q := X9X11X12X14 ¯q; ∫w+2 := Z9 end 17 QECV: A Veriﬁcation Framework for Quantum Error Correction Codes A PREPRINT if M [∫w+3, q14] then skip else ¯q := X14X16X17X18 ¯q; ∫w+1 := Z14 end; ∫1 := X4X6X7X9; ∫2 := X9X11X12X14; correct(∫0, ∫1, · · · ). Proposition A.1 (Initialize |0L⟩). For the program Prog in Program A.1 which initializes a X-cut logical qubit to |0L⟩, {I}Prog{Z4Z9Z14}. Here Z4Z9Z14 is the logical Z operator ZL. Proof. By Proposition 4.8, after correct function, (ρ, σ) |= (∫0 ∧ ∫1 ∧ ∫2 · · · ). The following stabilizer assignments which turn off X-stabilizers will just forward the precondition. For simplicity, assume there are w stabilizers in the surface code array. let Λ = {0, · · · , w − 1}, then (∫0 ∧ ∫1 ∧ ∫2 · · · ) = ∧i∈Λ∫i. Since ∫0 ∧ ∫1 ⇒ X0X1X2X6X7X9 and X0X1X2X6X7X9 is commutable with Z4, {∧i∈Λ∫i}∫w+1 := Z4{(∧i∈Λ\\{0,1}∫i) ∧ X0X1X2X6X7X9}. Likewise, we know that after ∫w+2 := Z9, the precondition will become {(∧i∈Λ\\{0,1,2,3}∫i) ∧ X0X1X2X6X7X11X12X16X17X18}. Note that (∧i∈Λ\\{0,1,2,3}∫i) ∧ X0X1X2X6X7X11X12X16X17X18 ⇒ X0X1X2X6X7X11X12X16X17X18. Let A = X0X1X2X6X7X11X12X16X17X18, c = if M [∫w+1, q4] then skip else ¯q := X4X6X7X9 ¯q; ∫w+1 := Z4 end. It’s easy to see that {A ∧ Z4}skip{A ∧ Z4}, and {A ∧ −Z4}q4 := Xq4; ∫w+1 := Z4{A ∧ Z4}. Thus, {A}c{A ∧ Z4}. Then, after reset q14 to |0⟩, the precondition will become: {A ∧ Z4 ∧ Z9 ∧ Z14}. Again, the following stabilizer assignments will just forward the precondition. By the implication rule, we have that A ∧ Z4 ∧ Z9 ∧ Z14 ⇒ A ∧ Z4Z9Z14. Since Z4Z9Z14 and all assertions in A are commutable with stabilizers ∫0, ∫1, · · · , we have {A ∧ Z4Z9Z14}correct(∫0, ∫1, · · · ){∧i∈Λ∫i ∧ Z4Z9Z14 ∧ X0X1X2X6X7X11X12X16X17X18}. Then by applying the consequence rule, we get {I}Prog{Z4Z9Z14}. Program A.2 (Logical X gate). For the logical X gate XL in the Figure below: we have Prog ::= q0q1q2q4 := X0X1X2X4q0q1q2q4. Proposition A.2 (Logical X gate). For program Prog in Figure 8(d), we have {ZL}Prog{−ZL} and {−ZL}Prog{ZL}, where ZL = Z4Z9Z14. Proof. Notice that (XL)(ZL)(XL) † = −ZL. Lemma 7.3. For a X-cut qubit state |ψ⟩, if |ψ⟩ = α|0⟩L + β|1⟩L (|α| 2 + |β| 2 = 1), then there is a unique (aZL + bXL) s.t. (aZL + bXL)|ψ⟩ = |ψ⟩, and in this case a = α 2−β2 α2+β2 and b = 2αβ α2+β2 . Conversely, for a X-cut qubit state |ψ⟩, if ( α 2−β2 α2+β2 ZL + 2αβ α2+β2 XL) ∗ |ψ⟩ = |ψ⟩, and |ψ⟩ is in the space spanned by {|0L⟩, |1L⟩}, then |ψ⟩ = α|0⟩L + β|1⟩L, up to a global phase. Proof. For the ﬁrst part, we can get a = α2−β2 α2+β2 and b = 2αβ α2+β2 simply by solving the equation (aZL + bXL)|ψ⟩ = |ψ⟩. For the second part, assume |ψ0⟩ = α0ZL + β0XL and |ψ1⟩ = α1ZL + β1XL, if there is a aZL + bXL s.t. (aZL + bXL)|ψ0⟩ = |ψ0⟩ and (aZL + bXL)|ψ1⟩ = |ψ1⟩. Then, we have a = ( α 2 0−β2 0 α2 0+β2 0 = ( α 2 1−β2 1 α2 1+β2 1 , which is equivalent to 1 − 2 1+( α0 β0 )2 = 1 − 2 1+( α1 β1 )2 . Thus, ( α0 β0 ) 2 = ( α1 β1 )2. On the other hand, b = 2α0β0 α2 0+β2 0 = 2α1β1 α2 1+β2 1 , which is equivalent to α0 β0 1+( α0 β0 )2 = α1 β1 1+( α1 β1 )2 . Thus, α0 β0 = α1 β1 , i.e., |ψ0⟩ = |ψ1⟩ up to a global phase. 18 QECV: A Veriﬁcation Framework for Quantum Error Correction Codes A PREPRINT Proposition 7.4 (Vertical qubit moving). For program Prog in Figure 8(c) which implements the qubit moving operation in Figure 7(c) , we have {aZL + bXL}Prog{aZ ′ L + bX ′ L}, where ZL = Z0Z1Z2, XL = X2X3X4X6, Z ′ L = Z0Z1Z2Z6, X ′ L = X6X8X9X10, a, b ∈ C. Proof. After the ﬁrst correction function, the precondition is transformed into: (aZL + bXL) ∧i ∫i. The three following stabilizer assignments will forward the precondition. Then by the implication rule, (aZL + bXL) ∧i ∫i ⇒ (aZL + bX2X3X4X8X9X10) ∧i̸=1 ∫i. so for the next stabilizer assignment ∫w+1 = Z6, precondition (aZL + bX2X3X4X8X9X10) ∧i̸=1 ∫i will be forwarded. Note that (aZL + bX2X3X4X8X9X10) ∧i̸=1 ∫i ⇒ aZL + bX2X3X4X8X9X10, let A = aZL + bX2X3X4X8X9X10, c = if M [∫w+1, ¯q] then skip else ¯q := X6X8X9X10 ¯q; ∫w+1 = Z6 end. For the if statement, {A ∧ ∫w+1}skip{A ∧ ∫w+1} and {A ∧ −∫w+1}¯q := X6X8X9X10 ¯q; ∫w+1 = Z6{A ∧ ∫w+1}, then {A}c{A ∧ ∫w+1}. By implication rule, A ∧ ∫w+1 ⇒ aZLZ6 + bX2X3X4X8X9X10. The next three stabilizer assignment will forward aZLZ6 + bX2X3X4X8X9X10. Then with the correct function and the consequence rule, we get that {aZL + bXL}Prog{aZ ′ L + bX ′ L}, i.e., the logical state is not changed by the qubit moving operation. A braiding operation involves many data qubits, and at least 51 data qubits will be referenced in the problem. To simplify the program, we will use the qubit moving as primitive. qmov(XL, X ′ L) means to move the defect that changes the logical X operation of a X-cut qubit from XL to X ′ L, and qmov(ZL, Z ′ L) to move the defect that changes the logical Z operation of a Z-cut qubit from ZL to Z ′ L. Program A.3 (Braiding). In the ﬁgure below, we braid a Z-cut qubit with a X-cut qubit: The associated program is Prog ::= qmov(Z5Z9Z10Z15, Z15Z20Z21Z26) qmov(Z15Z20Z21Z26, Z26Z31Z32Z37) qmov(Z26Z31Z32Z37, Z37Z42Z43Z47) qmov(Z37Z42Z43Z47, Z38Z43Z44Z48) 19 QECV: A Veriﬁcation Framework for Quantum Error Correction Codes A PREPRINT qmov(Z38Z43Z44Z48, Z39Z44Z45Z49) qmov(Z39Z44Z45Z49, Z40Z45Z46Z50) qmov(Z40Z45Z46Z50, Z29Z34Z35Z40) qmov(Z29Z34Z35Z40, Z18Z23Z24Z29) qmov(Z18Z23Z24Z29, Z8Z12Z13Z18) qmov(Z8Z12Z13Z18, Z7Z11Z12Z17) qmov(Z7Z11Z12Z17, Z6Z10Z11Z16) qmov(Z6Z10Z11Z16, Z5Z9Z10Z15) According to Fowler, the veriﬁcation of the braiding operation only need to focus on four conﬁgurations of logical states on a pair of logical qubits: XL1 ⊗ IL2, IL1 ⊗ XL2, IL1 ⊗ ZL2 and ZL1 ⊗ IL2. Proposition A.3 (Braiding). For the program Prog in Program A.3, {XL1IL2}Prog{XL1XL2}, {IL1ZL2}Prog{ZL1ZL2}, {IL1XL2}Prog{IL1XL2} and {ZL1IL2}Prog{ZL1IL2}. Proof. To simplify the proof, we let AS = ∧i∫i, i.e., the assertion generated by current active stabilizers in the surface code array. Note that AS may change at different time-step. The proof of the braiding operation involves tedious computation and we only give a sketch of the proof here. (1) Prove {XL1IL2}Prog{XL1XL2}. Since XL1IL2 = XL1, we only need to focus on the reasoning on XL1 only. From the veriﬁca- tion of the qubit moving, {XL1IL2}qmov(Z5Z9Z10Z15, Z15Z20Z21Z26){XL1X15IL2} (after correct function, {XL1IL2 ∧ X15 ∧ AS becomes {XL1X15IL2 ∧ AS). Then, after all these qubit moving operations, we will get {XL1IL2}Prog{XL1X15X26X37X43X44X45X29X18X12X11X10IL2 ∧ AS}. Apply implication rule on AS, we get AS ⇒ (X10X15X16X21)(X21X26X27X32)(X32X37X38X43)(X33X38X39X44)(X34X39X40X45) (X23X28X29X34)(X12X17X18X23)(X11X16X17X22) = (X15X26X37X43X44X45X29X18X12X11X10)(X27X33X28X22). Then, by the consequence rule, we have {XL1IL2}Prog{XL1XL2}. (2) Prove {IL1ZL2}Prog{ZL1ZL2}. Before the qubit moving operation involves qubits in ZL2, the precondition {IL1ZL2} will be forwarded by the qubit moving operation. So, we only need to elaborate on qmov(Z38Z43Z44Z48, Z39Z44Z45Z49). Before measuring q44 in X basis, the assignment statement about X44 will turn the precondition {IL1ZL2} into ZL2(Z39Z44Z45Z49), following the previous veriﬁcation steps of qubit moving. The if statement on X44 and q44 will then transform the precondition into ZL2(Z39Z44Z45Z49) ∧ X44. The following assignment statement about Z38Z43Z44Z48 will turn the precondition ZL2(Z39Z44Z45Z49) ∧ X44 into ZL2(Z39Z44Z45Z49). Likewise, the remaining qubit moving operations will change the precondition ZL2(Z39Z44Z45Z49) to ZL2(Z40Z45Z46Z50), · · · , until ZL2(Z5Z9Z10Z15), which is just ZL1ZL2. Thus, {IL1ZL2}Prog{ZL1ZL2}. (3) Prove {IL1XL2}Prog{IL1XL2}. Recall the veriﬁcation of the qubit moving operation. It is easy to see that {IL1}qmov{IL1} for any qubit moving operation in P . On the other hand, the qubit moving operations in P does not involve any qubits in XL2, so precondition IL1XL2 will be forwarded by all qubit moving operations, i.e., {IL1XL2}Prog{IL1XL2}. (4) Prove {ZL1IL2}Prog{ZL1IL2}. Since ZL1IL2 = ZL1, we only focus on the reasoning of ZL1 here. It is obvious that starting from Z5Z9Z10Z15, the logical Z operator ﬁnally returns to Z5Z9Z10Z15 by a series of qubit moving operations. Thus, {ZL1IL2}Prog{ZL1IL2}. 20","libVersion":"0.2.3","langs":""}